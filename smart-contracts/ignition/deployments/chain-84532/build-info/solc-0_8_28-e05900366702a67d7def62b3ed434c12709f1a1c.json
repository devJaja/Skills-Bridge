{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-e05900366702a67d7def62b3ed434c12709f1a1c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SkillBridge.sol": "project/contracts/SkillBridge.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/libs/Events.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary Events {\n    event JobApplication(address indexed applicant, uint256 indexed listingId);\n    event ProfileUpdated(address indexed userAddress);\n    event JobListingPosted(uint256 indexed listingId, address indexed client);\n    event JobListingClosed(uint256 indexed listingId);\n     // Escrow Events\n    event JobFunded(uint256 indexed jobId, uint256 indexed listingId, address indexed client, uint256 amount, uint256 deadline);\n    event ProviderAssigned(uint256 indexed jobId, address indexed provider);\n    event JobStarted(uint256 indexed jobId);\n    event JobCompleted(uint256 indexed jobId, uint256 completedAt);\n    event JobApproved(uint256 indexed jobId, uint256 amountReleased, uint256 rating);\n    event JobRejected(uint256 indexed jobId, string reason, uint256 rating);\n    event JobAutoReleased(uint256 indexed jobId, uint256 amountReleased, string reason);\n    event JobCancelled(uint256 indexed jobId, uint256 refundAmount);\n    event JobAutoRefunded(uint256 indexed jobId, uint256 refundAmount, string reason);\n    event EmergencyWithdraw(uint256 indexed jobId, uint256 refundAmount);\n    event ProviderFeedbackAdded(uint256 indexed jobId, string comment);\n}"
      },
      "project/contracts/SkillBridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./libs/Events.sol\";\n\n \ncontract SkillBridge is ReentrancyGuard {\n\n    enum UserType { ServiceProvider, Client }\n    \n    enum SkillCategory { \n        WebDevelopment, \n        MobileDevelopment, \n        DataScience, \n        BlockchainDev, \n        DevOps,\n        GraphicDesign, \n        ContentWriting, \n        VideoEditing, \n        UIUXDesign,\n        Construction, \n        Electrical, \n        Plumbing, \n        HomeMaintenance,\n        BusinessStrategy, \n        Marketing, \n        LegalServices, \n        FinancialPlanning\n    }\n    \n    enum WorkType { Remote, Physical, Both }\n    \n    enum JobStatus { Posted, Funded, InProgress, Completed, Approved, AutoReleased, Cancelled }\n\n    struct UserProfile {\n        string name;\n        string email;\n        SkillCategory[] skillCategories;\n        string location;\n        WorkType workType;\n        UserType userType;\n    }\n    \n    struct JobListing {\n        uint256 id;\n        string title;\n        string description;\n        uint256 budget;\n        uint256 deadline;\n        address client;\n        bool isOpen;\n    }\n    \n    struct Job {\n        uint256 id;\n        uint256 listingId;        // Reference to original job listing\n        address client;\n        address provider;\n        uint256 amount;\n        uint256 deadline;\n        uint256 completedAt;\n        JobStatus status;\n    }\n    \n    struct JobFeedback {\n        bool hasClientFeedback;\n        bool clientApproved;\n        string clientComment;\n        uint256 clientRating;       // 1-5 stars\n        bool hasProviderFeedback;\n        string providerComment;\n        uint256 feedbackTimestamp;\n    }\n    \n    // User Management\n    mapping(address => UserProfile) public userProfiles;\n    mapping(address => bool) public registeredUsers;\n    address[] public allUsers;\n    address[] public serviceProviders;\n    address[] public clients;\n    \n    // Job Listings\n    mapping(uint256 => JobListing) public jobListings;\n    uint256 public jobListingCount;\n    \n    // Escrow Jobs\n    mapping(uint256 => Job) public jobs;\n    mapping(uint256 => JobFeedback) public jobFeedbacks;\n    uint256 public jobCounter;\n    \n    // Reputation System\n    mapping(address => uint256) public userRatings;\n    mapping(address => uint256) public userRatingCounts;\n\n    mapping(uint256 => address[]) public jobApplicants; // listingId => array of applicant addresses\n    \n    uint256 public constant CLIENT_RESPONSE_GRACE_PERIOD = 7 days;\n\n    modifier onlyRegistered() {\n        require(registeredUsers[msg.sender], \"User not registered\");\n        _;\n    }\n    \n    modifier onlyClient() {\n        require(\n            registeredUsers[msg.sender] &&\n            userProfiles[msg.sender].userType == UserType.Client,\n            \"Only clients can perform this action\"\n        );\n        _;\n    }\n    \n    modifier onlyProvider() {\n        require(\n            registeredUsers[msg.sender] &&\n            userProfiles[msg.sender].userType == UserType.ServiceProvider,\n            \"Only service providers can perform this action\"\n        );\n        _;\n    }\n    \n    modifier onlyJobClient(uint256 _jobId) {\n        require(msg.sender == jobs[_jobId].client, \"Not job client\");\n        _;\n    }\n    \n    modifier onlyJobProvider(uint256 _jobId) {\n        require(msg.sender == jobs[_jobId].provider, \"Not job provider\");\n        _;\n    }\n    \n    modifier jobExists(uint256 _jobId) {\n        require(jobs[_jobId].client != address(0), \"Job does not exist\");\n        _;\n    }\n    \n    modifier listingExists(uint256 _listingId) {\n        require(jobListings[_listingId].client != address(0), \"Job listing does not exist\");\n        _;\n    }\n    \n    event UserRegistered(address indexed userAddress, UserType userType);\n     //Register a new user on the platform\n     \n    function registerUser(\n        string memory _name,\n        string memory _email,\n        SkillCategory[] memory _skillCategories,\n        string memory _location,\n        WorkType _workType,\n        UserType _userType\n    ) external nonReentrant {\n        require(!registeredUsers[msg.sender], \"Already registered\");\n        require(bytes(_name).length > 0, \"Name required\");\n        require(bytes(_email).length > 0, \"Email required\");\n        \n        UserProfile storage newUser = userProfiles[msg.sender];\n        newUser.name = _name;\n        newUser.email = _email;\n        newUser.skillCategories = _skillCategories;\n        newUser.location = _location;\n        newUser.workType = _workType;\n        newUser.userType = _userType;\n        \n        registeredUsers[msg.sender] = true;\n        allUsers.push(msg.sender);\n        \n        if (_userType == UserType.ServiceProvider) {\n            serviceProviders.push(msg.sender);\n        } else {\n            clients.push(msg.sender);\n        }\n        \n        emit UserRegistered(msg.sender, _userType);\n    }\n    \n   //Update user profile information\n     \n    function updateProfile(\n        string memory _name,\n        string memory _email,\n        SkillCategory[] memory _skillCategories,\n        string memory _location,\n        WorkType _workType\n    ) external onlyRegistered nonReentrant {\n        UserProfile storage user = userProfiles[msg.sender];\n        user.name = _name;\n        user.email = _email;\n        user.skillCategories = _skillCategories;\n        user.location = _location;\n        user.workType = _workType;\n        \n        emit Events.ProfileUpdated(msg.sender);\n    }\n   \n    //Post a new job listing\n     \n    function postJobListing(\n        string memory _title,\n        string memory _description,\n        uint256 _budget,\n        uint256 _deadline\n    ) external onlyClient nonReentrant {\n        require(bytes(_title).length > 0, \"Title required\");\n        require(bytes(_description).length > 0, \"Description required\");\n        require(_budget > 0, \"Budget must be greater than 0\");\n        require(_deadline > block.timestamp, \"Deadline must be in future\");\n        \n        jobListingCount++;\n        jobListings[jobListingCount] = JobListing({\n            id: jobListingCount,\n            title: _title,\n            description: _description,\n            budget: _budget,\n            deadline: _deadline,\n            client: msg.sender,\n            isOpen: true\n        });\n        \n        emit Events.JobListingPosted(jobListingCount, msg.sender);\n    }\n    \n    // Close a job listing\n     \n    function closeJobListing(uint256 _listingId) \n        external \n        listingExists(_listingId) \n        onlyClient \n    {\n        require(jobListings[_listingId].client == msg.sender, \"Not listing owner\");\n        require(jobListings[_listingId].isOpen, \"Listing already closed\");\n        \n        jobListings[_listingId].isOpen = false;\n        emit Events.JobListingClosed(_listingId);\n    }\n    \n    //Fund a job from a listing and start escrow\n     \n    function fundJobFromListing(uint256 _listingId, address _provider) \n        external \n        payable \n        listingExists(_listingId) \n        onlyClient \n        nonReentrant \n    {\n        JobListing storage listing = jobListings[_listingId];\n        require(listing.client == msg.sender, \"Not listing owner\");\n        require(listing.isOpen, \"Listing is closed\");\n        require(msg.value >= listing.budget, \"Insufficient funds\");\n        require(_provider != address(0), \"Invalid provider\");\n        require(registeredUsers[_provider], \"Provider not registered\");\n        require(userProfiles[_provider].userType == UserType.ServiceProvider, \"Address is not a service provider\");\n        \n        jobCounter++;\n        jobs[jobCounter] = Job({\n            id: jobCounter,\n            listingId: _listingId,\n            client: msg.sender,\n            provider: _provider,\n            amount: msg.value,\n            deadline: listing.deadline,\n            completedAt: 0,\n            status: JobStatus.Funded\n        });\n        \n        // Close the listing as it's now funded\n        listing.isOpen = false;\n        \n        emit Events.JobFunded(jobCounter, _listingId, msg.sender, msg.value, listing.deadline);\n        emit Events.ProviderAssigned(jobCounter, _provider);\n        emit Events.JobListingClosed(_listingId);\n    }\n    //Fund a direct job (without listing)\n     \n    function fundDirectJob(uint256 _deadline, address _provider) \n        external \n        payable \n        onlyClient \n        nonReentrant \n    {\n        require(msg.value > 0, \"Must send funds\");\n        require(_deadline > block.timestamp, \"Deadline must be in future\");\n        require(_provider != address(0), \"Invalid provider\");\n        require(registeredUsers[_provider], \"Provider not registered\");\n        require(userProfiles[_provider].userType == UserType.ServiceProvider, \"Address is not a service provider\");\n        \n        jobCounter++;\n        jobs[jobCounter] = Job({\n            id: jobCounter,\n            listingId: 0, // No listing for direct jobs\n            client: msg.sender,\n            provider: _provider,\n            amount: msg.value,\n            deadline: _deadline,\n            completedAt: 0,\n            status: JobStatus.Funded\n        });\n        \n        emit Events.JobFunded(jobCounter, 0, msg.sender, msg.value, _deadline);\n        emit Events.ProviderAssigned(jobCounter, _provider);\n    }\n    \n    //Provider starts the job\n     \n    function startJob(uint256 _jobId) \n        external \n        jobExists(_jobId) \n        onlyJobProvider(_jobId) \n    {\n        require(jobs[_jobId].status == JobStatus.Funded, \"Job not ready to start\");\n        require(block.timestamp <= jobs[_jobId].deadline, \"Job deadline passed\");\n        \n        jobs[_jobId].status = JobStatus.InProgress;\n        emit Events.JobStarted(_jobId);\n    }\n    \n    //Provider marks job as completed\n     \n    function markCompleted(uint256 _jobId) \n        external \n        jobExists(_jobId) \n        onlyJobProvider(_jobId) \n    {\n        require(jobs[_jobId].status == JobStatus.InProgress, \"Job not in progress\");\n        require(block.timestamp <= jobs[_jobId].deadline, \"Cannot complete after deadline\");\n        \n        jobs[_jobId].status = JobStatus.Completed;\n        jobs[_jobId].completedAt = block.timestamp;\n        \n        emit Events.JobCompleted(_jobId, block.timestamp);\n    }\n    \n    // Client approves work and releases funds\n     \n    function approveWork(uint256 _jobId, uint256 _rating, string calldata _comment) \n        external \n        jobExists(_jobId) \n        onlyJobClient(_jobId) \n        nonReentrant \n    {\n        require(jobs[_jobId].status == JobStatus.Completed, \"Work not completed\");\n        require(_rating >= 1 && _rating <= 5, \"Rating must be 1-5\");\n        require(!jobFeedbacks[_jobId].hasClientFeedback, \"Feedback already provided\");\n        \n        // Release funds immediately\n        jobs[_jobId].status = JobStatus.Approved;\n        uint256 payment = jobs[_jobId].amount;\n        jobs[_jobId].amount = 0;\n        \n        // Record feedback and update reputation\n        JobFeedback storage feedback = jobFeedbacks[_jobId];\n        feedback.hasClientFeedback = true;\n        feedback.clientApproved = true;\n        feedback.clientComment = _comment;\n        feedback.clientRating = _rating;\n        feedback.feedbackTimestamp = block.timestamp;\n        \n        // Update provider's reputation\n        userRatings[jobs[_jobId].provider] += _rating;\n        userRatingCounts[jobs[_jobId].provider]++;\n        \n        payable(jobs[_jobId].provider).transfer(payment);\n        \n        emit Events.JobApproved(_jobId, payment, _rating);\n    }\n    \n   \n    function rejectWork(uint256 _jobId, uint256 _rating, string calldata _reason) \n        external \n        jobExists(_jobId) \n        onlyJobClient(_jobId) \n    {\n        require(jobs[_jobId].status == JobStatus.Completed, \"Work not completed\");\n        require(_rating >= 1 && _rating <= 5, \"Rating must be 1-5\");\n        require(!jobFeedbacks[_jobId].hasClientFeedback, \"Feedback already provided\");\n        \n        // Record rejection feedback\n        JobFeedback storage feedback = jobFeedbacks[_jobId];\n        feedback.hasClientFeedback = true;\n        feedback.clientApproved = false;\n        feedback.clientComment = _reason;\n        feedback.clientRating = _rating;\n        feedback.feedbackTimestamp = block.timestamp;\n        \n        // Update provider's reputation\n        userRatings[jobs[_jobId].provider] += _rating;\n        userRatingCounts[jobs[_jobId].provider]++;\n        \n        emit Events.JobRejected(_jobId, _reason, _rating);\n    }\n    \n    //Auto-release funds after grace period\n     \n    function autoReleaseAfterGracePeriod(uint256 _jobId) \n        external \n        jobExists(_jobId) \n        nonReentrant \n    {\n        Job storage job = jobs[_jobId];\n        \n        require(job.status == JobStatus.Completed, \"Work not completed\");\n        require(job.completedAt > 0, \"Completion time not recorded\");\n        require(\n            block.timestamp > job.completedAt + CLIENT_RESPONSE_GRACE_PERIOD,\n            \"Grace period not expired\"\n        );\n        \n        job.status = JobStatus.AutoReleased;\n        uint256 payment = job.amount;\n        job.amount = 0;\n        \n        payable(job.provider).transfer(payment);\n        emit Events.JobAutoReleased(_jobId, payment, \"Client response grace period expired - auto-released\");\n    }\n    \n    //Auto-refund if provider misses deadline\n     \n    function autoRefundMissedDeadline(uint256 _jobId) \n        external \n        jobExists(_jobId) \n        nonReentrant \n    {\n        Job storage job = jobs[_jobId];\n        \n        require(\n            job.status == JobStatus.InProgress || job.status == JobStatus.Funded,\n            \"Job not eligible for auto-refund\"\n        );\n        require(block.timestamp > job.deadline, \"Deadline not passed yet\");\n        require(job.completedAt == 0, \"Work was completed on time\");\n        \n        job.status = JobStatus.Cancelled;\n        uint256 refund = job.amount;\n        job.amount = 0;\n        \n        payable(job.client).transfer(refund);\n        emit Events.JobAutoRefunded(_jobId, refund, \"Provider missed deadline\");\n    }\n    \n   //Cancel funded job (only if provider hasn't started)\n     \n    function cancelJob(uint256 _jobId) \n        external \n        jobExists(_jobId) \n        onlyJobClient(_jobId) \n        nonReentrant \n    {\n        require(jobs[_jobId].status == JobStatus.Funded, \"Can only cancel funded jobs\");\n        \n        jobs[_jobId].status = JobStatus.Cancelled;\n        uint256 refund = jobs[_jobId].amount;\n        jobs[_jobId].amount = 0;\n        \n        payable(jobs[_jobId].client).transfer(refund);\n        emit Events.JobCancelled(_jobId, refund);\n    }\n    \n    //Emergency withdraw for funded jobs\n     \n    function emergencyWithdraw(uint256 _jobId) \n        external \n        jobExists(_jobId) \n        onlyJobClient(_jobId) \n        nonReentrant \n    {\n        require(jobs[_jobId].status == JobStatus.Funded, \"Job not in funded state\");\n        \n        uint256 refund = jobs[_jobId].amount;\n        jobs[_jobId].amount = 0;\n        jobs[_jobId].status = JobStatus.Cancelled;\n        \n        payable(msg.sender).transfer(refund);\n        emit Events.EmergencyWithdraw(_jobId, refund);\n    }\n    \n    function addProviderResponse(uint256 _jobId, string calldata _response) \n        external \n        jobExists(_jobId) \n        onlyJobProvider(_jobId) \n    {\n        require(\n            jobs[_jobId].status == JobStatus.Approved || jobs[_jobId].status == JobStatus.AutoReleased,\n            \"Job not completed yet\"\n        );\n        require(jobFeedbacks[_jobId].hasClientFeedback, \"No client feedback to respond to\");\n        \n        JobFeedback storage feedback = jobFeedbacks[_jobId];\n        feedback.hasProviderFeedback = true;\n        feedback.providerComment = _response;\n        \n        emit Events.ProviderFeedbackAdded(_jobId, _response);\n    }\n\n    function applyForJob(uint256 _listingId) external onlyRegistered nonReentrant {\n        require(jobListings[_listingId].client != address(0), \"Job listing does not exist\");\n        require(jobListings[_listingId].isOpen, \"Job listing is not open for applications\");\n        require(userProfiles[msg.sender].userType == UserType.ServiceProvider, \"Only service providers can apply\");\n\n        // Check if already applied\n        bool alreadyApplied = false;\n        for (uint256 i = 0; i < jobApplicants[_listingId].length; i++) {\n            if (jobApplicants[_listingId][i] == msg.sender) {\n                alreadyApplied = true;\n                break;\n            }\n        }\n        require(!alreadyApplied, \"Already applied for this job\");\n\n        jobApplicants[_listingId].push(msg.sender);\n        emit Events.JobApplication(msg.sender, _listingId);\n    }\n    \n    \n    // User View Functions\n    function getTotalUsers() external view returns (uint256) {\n        return allUsers.length;\n    }\n    \n    function getAllServiceProviders() external view returns (address[] memory) {\n        return serviceProviders;\n    }\n    \n    function getAllClients() external view returns (address[] memory) {\n        return clients;\n    }\n    \n    function getUserSkills(address _userAddress) \n        external \n        view \n        returns (SkillCategory[] memory) \n    {\n        require(registeredUsers[_userAddress], \"User not registered\");\n        return userProfiles[_userAddress].skillCategories;\n    }\n    \n    function getUserAverageRating(address _user) external view returns (uint256) {\n        if (userRatingCounts[_user] == 0) return 0;\n        return userRatings[_user] / userRatingCounts[_user];\n    }\n    \n    function getUserRatingCount(address _user) external view returns (uint256) {\n        return userRatingCounts[_user];\n    }\n    \n    // Job Listing View Functions\n    function getJobListing(uint256 _listingId) external view returns (JobListing memory) {\n        return jobListings[_listingId];\n    }\n    \n    function getOpenJobListings() external view returns (JobListing[] memory) {\n        uint256 openCount = 0;\n        \n        // Count open listings\n        for (uint256 i = 1; i <= jobListingCount; i++) {\n            if (jobListings[i].isOpen) {\n                openCount++;\n            }\n        }\n        \n        // Create array of open listings\n        JobListing[] memory openListings = new JobListing[](openCount);\n        uint256 currentIndex = 0;\n        \n        for (uint256 i = 1; i <= jobListingCount; i++) {\n            if (jobListings[i].isOpen) {\n                openListings[currentIndex] = jobListings[i];\n                currentIndex++;\n            }\n        }\n        \n        return openListings;\n    }\n\n    function getClientJobListings(address _clientAddress) external view returns (JobListing[] memory) {\n        uint256 clientJobCount = 0;\n        for (uint256 i = 1; i <= jobListingCount; i++) {\n            if (jobListings[i].client == _clientAddress) {\n                clientJobCount++;\n            }\n        }\n\n        JobListing[] memory clientListings = new JobListing[](clientJobCount);\n        uint256 currentIndex = 0;\n        for (uint256 i = 1; i <= jobListingCount; i++) {\n            if (jobListings[i].client == _clientAddress) {\n                clientListings[currentIndex] = jobListings[i];\n                currentIndex++;\n            }\n        }\n        return clientListings;\n    }\n    \n    // Escrow View Functions\n    function getJob(uint256 _jobId) external view returns (Job memory) {\n        return jobs[_jobId];\n    }\n    \n    function getJobFeedback(uint256 _jobId) external view returns (JobFeedback memory) {\n        return jobFeedbacks[_jobId];\n    }\n    \n    function canAutoRefund(uint256 _jobId) external view returns (bool) {\n        Job storage job = jobs[_jobId];\n        return (\n            (job.status == JobStatus.InProgress || job.status == JobStatus.Funded) &&\n            block.timestamp > job.deadline &&\n            job.completedAt == 0\n        );\n    }\n    \n    function canAutoRelease(uint256 _jobId) external view returns (bool) {\n        Job storage job = jobs[_jobId];\n        return (\n            job.status == JobStatus.Completed &&\n            job.completedAt > 0 &&\n            block.timestamp > job.completedAt + CLIENT_RESPONSE_GRACE_PERIOD\n        );\n    }\n    \n    function getTimeUntilDeadline(uint256 _jobId) external view returns (uint256) {\n        Job storage job = jobs[_jobId];\n        if (block.timestamp >= job.deadline) return 0;\n        return job.deadline - block.timestamp;\n    }\n    \n    function getTimeUntilAutoRelease(uint256 _jobId) external view returns (uint256) {\n        Job storage job = jobs[_jobId];\n        if (job.status != JobStatus.Completed || job.completedAt == 0) return 0;\n        \n        uint256 autoReleaseTime = job.completedAt + CLIENT_RESPONSE_GRACE_PERIOD;\n        if (block.timestamp >= autoReleaseTime) return 0;\n        return autoReleaseTime - block.timestamp;\n    }\n    \n    function getUserJobHistory(address _user) external view returns (uint256[] memory) {\n        uint256[] memory tempJobs = new uint256[](jobCounter);\n        uint256 count = 0;\n        \n        for (uint256 i = 1; i <= jobCounter; i++) {\n            if (jobs[i].client == _user || jobs[i].provider == _user) {\n                tempJobs[count] = i;\n                count++;\n            }\n        }\n        \n        uint256[] memory userJobs = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            userJobs[i] = tempJobs[i];\n        }\n        \n        return userJobs;\n    }\n}"
      }
    }
  }
}