import type { Seaport } from '@opensea/seaport-js';
import type { CreateOrderInput, Fee, OrderWithCounter } from '@opensea/seaport-js/lib/types';

import { SeaportOperationHandler } from '../seaport-operation.handler';
import { DomaOrderbookError, DomaOrderbookErrorCode } from '../../errors';

import type { CreateListingParams, CreateListingResult, ListingItem } from './types';
import {
  HOURS_IN_DAY,
  MILLISECONDS_IN_SECOND,
  MINUTES_IN_HOUR,
  SECONDS_IN_MINUTE,
} from '../../utils/date.utils';
import { buildListingOrderInput, prepareFees } from '../../utils/seaport-order.utils';
import { CreateListingResponse } from '../../api/types';
import { getOrderbookConduitKey, getOrderbookZone } from '../../utils/orderbook-zone.utils';
import { parseChainId } from '../../utils/chain.utils';
import { OrderbookType } from '../../types';

export class ListingHandler extends SeaportOperationHandler<
  CreateListingParams,
  CreateListingResult
> {
  private readonly DEFAULT_LIST_DURATION =
    HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND;

  public async execute(params: CreateListingParams): Promise<CreateListingResult> {
    try {
      const { items, marketplaceFees } = params;

      this.validateInputs(items);
      await this.validateCurrency(items, params.orderbook);
      const walletAddress = await this.getWalletAddress();
      const fees = prepareFees(marketplaceFees);

      if (items.length === 1) {
        return await this.handleSingleListing(items[0], walletAddress, this.seaport, fees, params);
      }

      return await this.handleBulkListing(items, walletAddress, this.seaport, fees, params);
    } catch (error) {
      throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.LISTING_CREATION_FAILED, {
        chainId: this.chainId,
        params,
      });
    }
  }

  private validateInputs(items: ListingItem[] | undefined): void {
    if (!items?.length) {
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.INVALID_PARAMETERS,
        'At least one item must be provided',
      );
    }
  }

  private async validateCurrency(items: ListingItem[], orderbook: OrderbookType): Promise<void> {
    const currencyContractAddress = items[0].currencyContractAddress;

    // we assume native currency
    if (currencyContractAddress === undefined) {
      return;
    }

    // check if all currencies are same
    const sameCurrency = items.every(
      (item) => item.currencyContractAddress === currencyContractAddress,
    );
    if (!sameCurrency) {
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.CURRENCY_NOT_SAME,
        `All currencies must be the same`,
      );
    }

    // Load supported currencies
    const itemContractAddress = items[0].contract;
    const currenciesResponse = await this.apiClient.getSupportedCurrencies({
      contractAddress: itemContractAddress,
      chainId: this.chainId,
      orderbook: orderbook,
    });

    const supportedCurrency = currenciesResponse.currencies.find(
      (currency) => currency.contractAddress === currencyContractAddress,
    );
    if (!supportedCurrency) {
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.CURRENCY_NOT_SUPPORTED,
        `Currency not supported`,
      );
    }
  }

  private async handleSingleListing(
    item: ListingItem,
    walletAddress: string,
    seaport: Seaport,
    fees: Fee[],
    params: CreateListingParams,
  ): Promise<CreateListingResult> {
    const endTime = Math.floor(
      (Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND,
    );

    const createOrderInput: CreateOrderInput = buildListingOrderInput(
      item,
      walletAddress,
      endTime,
      fees,
      getOrderbookZone(params.orderbook, parseChainId(this.chainId)),
      getOrderbookConduitKey(params.orderbook),
    );

    const orderUseCase = await seaport.createOrder(createOrderInput, walletAddress);

    const result = await this.executeBlockchainOperation<OrderWithCounter>(orderUseCase.actions);

    const listingResponse = await this.apiClient.createListing({
      signature: result.signature,
      orderbook: params.orderbook,
      chainId: this.chainId,
      parameters: result.parameters,
      cancelExisting: params.cancelExisting,
    });

    return {
      orders: [{ orderId: listingResponse.orderId, orderData: result }],
    };
  }

  private async handleBulkListing(
    items: ListingItem[],
    walletAddress: string,
    seaport: Seaport,
    fees: Fee[],
    params: CreateListingParams,
  ): Promise<CreateListingResult> {
    const createOrderInputs = items.map((item) => {
      const endTime = Math.floor(
        (Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND,
      );

      return buildListingOrderInput(
        item,
        walletAddress,
        endTime,
        fees,
        getOrderbookZone(params.orderbook, parseChainId(this.chainId)),
        getOrderbookConduitKey(params.orderbook),
      );
    });

    const bulkOrderUseCase = await seaport.createBulkOrders(createOrderInputs, walletAddress);

    const results = await this.executeBlockchainOperation<OrderWithCounter[]>(
      bulkOrderUseCase.actions,
    );

    const listingResponse = await this.apiClient.createBulkListing({
      orders: results.map((result) => ({
        signature: result.signature,
        parameters: result.parameters,
      })),
      orderbook: params.orderbook,
      chainId: this.chainId,
    });

    return {
      orders: listingResponse.orders.map((order: CreateListingResponse) => {
        return {
          orderId: order.orderId,
          orderData: {
            signature: order.signature,
            parameters: order.orderData,
          },
        };
      }),
      errors: listingResponse.errors,
    };
  }
}
