import type { Seaport } from '@opensea/seaport-js';
import type { CreateOrderInput, Fee, OrderWithCounter } from '@opensea/seaport-js/lib/types';

import { SeaportOperationHandler } from '../seaport-operation.handler';
import { DomaOrderbookError, DomaOrderbookErrorCode } from '../../errors';

import type { CreateOfferParams, CreateOfferResult, OfferItem } from './types';
import {
  HOURS_IN_DAY,
  MILLISECONDS_IN_SECOND,
  MINUTES_IN_HOUR,
  SECONDS_IN_MINUTE,
} from '../../utils/date.utils';
import { buildOfferOrderInput, prepareFees } from '../../utils/seaport-order.utils';
import { Weth__factory } from '../../contracts';
import type { BlockchainActions } from '../../core';
import {
  createWrapperCurrencyDepositTransaction,
  type WrapperCurrencyConversionAction,
} from '../actions/weth.action';
import { mapInputItemToOfferItem } from '@opensea/seaport-js/lib/utils/order';
import type { JsonRpcProvider, Signer } from 'ethers';
import {
  getBalancesAndApprovals,
  validateOfferBalancesAndApprovals,
} from '@opensea/seaport-js/lib/utils/balanceAndApprovalCheck';
import { getApprovalActions } from '@opensea/seaport-js/lib/utils/approval';
import { parseChainId } from '../../utils/chain.utils';
import { getOrderbookConduitKey, getOrderbookZone } from '../../utils/orderbook-zone.utils';
import { CreateOfferResponse } from '../../api/types';
import { CurrencyToken, OrderbookType } from '../../types';

export class CreateOfferHandler extends SeaportOperationHandler<
  CreateOfferParams,
  CreateOfferResult
> {
  private readonly DEFAULT_LIST_DURATION =
    HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND;

  public async execute(params: CreateOfferParams): Promise<CreateOfferResult> {
    try {
      const { items, marketplaceFees } = params;

      this.validateInputs(items);
      const walletAddress = await this.getWalletAddress();

      await this.validateBalances(items, walletAddress, params.orderbook);

      const fees = prepareFees(marketplaceFees);

      if (items.length === 1) {
        return await this.handleSingleOffer(items[0], walletAddress, this.seaport, fees, params);
      }

      return await this.handleBulkOffer(items, walletAddress, this.seaport, fees, params);
    } catch (error) {
      throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.OFFER_CREATION_FAILED, {
        chainId: this.chainId,
        params,
      });
    }
  }

  private validateInputs(items: OfferItem[] | undefined): void {
    if (!items?.length) {
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.INVALID_PARAMETERS,
        'At least one item must be provided',
      );
    }
  }

  private async validateBalances(
    items: OfferItem[],
    walletAddress: string,
    orderbook: OrderbookType,
  ): Promise<void> {
    const supportedCurrency = await this.validateCurrency(items, orderbook);

    // Group items by currency
    const itemsByCurrency = new Map<string, OfferItem[]>();
    for (const item of items) {
      const currency = item.currencyContractAddress.toLowerCase();
      if (!itemsByCurrency.has(currency)) {
        itemsByCurrency.set(currency, []);
      }
      itemsByCurrency.get(currency)!.push(item);
    }

    for (const [currencyAddress, currencyItems] of itemsByCurrency) {
      // Get the maximum amount needed (for offers, we need the max, not the sum)
      const maxAmountNeeded = currencyItems.reduce((max, item) => {
        const itemPrice = BigInt(item.price);
        return itemPrice > max ? itemPrice : max;
      }, 0n);

      // Check if this is a native wrapper currency
      if (
        supportedCurrency.nativeWrapper &&
        currencyAddress.toLowerCase() === supportedCurrency.contractAddress.toLowerCase()
      ) {
        // For native wrapper, check combined native + wrapper balance
        await this.validateNativeWrapperBalance(currencyAddress, maxAmountNeeded, walletAddress);
      } else {
        // For regular ERC20, just check token balance
        await this.validateTokenBalance(currencyAddress, maxAmountNeeded, walletAddress);
      }
    }
  }

  private async validateNativeWrapperBalance(
    wrapperAddress: string,
    amountNeeded: bigint,
    walletAddress: string,
  ): Promise<void> {
    const wrapperContract = Weth__factory.connect(wrapperAddress, this.signer);
    const wrapperBalance = await wrapperContract.balanceOf(walletAddress);

    if (wrapperBalance >= amountNeeded) {
      return;
    }

    const difference = amountNeeded - wrapperBalance;
    const nativeBalance = await this.signer.provider.getBalance(walletAddress);

    if (nativeBalance < difference) {
      const totalAvailable = wrapperBalance + nativeBalance;
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.INSUFFICIENT_BALANCE,
        `Insufficient balance: need ${amountNeeded.toString()} but only have ${totalAvailable.toString()} (${wrapperBalance.toString()} wrapped + ${nativeBalance.toString()} native)`,
        {
          required: amountNeeded.toString(),
          wrapperBalance: wrapperBalance.toString(),
          nativeBalance: nativeBalance.toString(),
          totalAvailable: totalAvailable.toString(),
        },
      );
    }
  }

  private async validateTokenBalance(
    tokenAddress: string,
    amountNeeded: bigint,
    walletAddress: string,
  ): Promise<void> {
    // Using Weth__factory works for any ERC20 since balanceOf is standard
    const tokenContract = Weth__factory.connect(tokenAddress, this.signer);
    const balance = await tokenContract.balanceOf(walletAddress);

    if (balance < amountNeeded) {
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.INSUFFICIENT_BALANCE,
        `Insufficient token balance: need ${amountNeeded.toString()} but only have ${balance.toString()}`,
        {
          tokenAddress,
          required: amountNeeded.toString(),
          available: balance.toString(),
        },
      );
    }
  }

  private async validateCurrency(
    items: OfferItem[],
    orderbook: OrderbookType,
  ): Promise<CurrencyToken> {
    const currencyContractAddress = items[0].currencyContractAddress;

    // check if all currencies are same
    const sameCurrency = items.every(
      (item) =>
        item.currencyContractAddress.toLowerCase() === currencyContractAddress.toLowerCase(),
    );
    if (!sameCurrency) {
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.CURRENCY_NOT_SAME,
        `All currencies must be the same`,
      );
    }

    // Load supported currencies
    const itemContractAddress = items[0].contract;
    const currenciesResponse = await this.apiClient.getSupportedCurrencies({
      contractAddress: itemContractAddress,
      chainId: this.chainId,
      orderbook: orderbook,
    });

    const supportedCurrency = currenciesResponse.currencies.find(
      (currency) =>
        currency.contractAddress.toLowerCase() === currencyContractAddress.toLowerCase(),
    );
    if (!supportedCurrency) {
      throw new DomaOrderbookError(
        DomaOrderbookErrorCode.CURRENCY_NOT_SUPPORTED,
        `Currency not supported`,
      );
    }

    return supportedCurrency;
  }

  private async createWrapperConversionAction(
    items: OfferItem[],
    walletAddress: string,
    wrapperContractAddress: string,
  ): Promise<WrapperCurrencyConversionAction | null> {
    const wrapperItems = items.filter(
      (item) => item.currencyContractAddress.toLowerCase() === wrapperContractAddress.toLowerCase(),
    );

    // We will assume WETH-Contract as template for wrapper currency
    const wrapperCurrency = Weth__factory.connect(wrapperContractAddress, this.signer);
    const wrapperCurrencyBalance = await wrapperCurrency.balanceOf(walletAddress);

    // Find the highest Wrapper Currency amount needed (for offers, we take the max, not sum)
    const maxWrapperCurrencyNeeded = wrapperItems.reduce((max, item) =>
      BigInt(item.price) > BigInt(max.price) ? item : max,
    );
    const difference = BigInt(maxWrapperCurrencyNeeded.price) - wrapperCurrencyBalance;

    if (difference > 0n) {
      // Balance should already be validated, but double-check
      const nativeBalance = await this.signer.provider.getBalance(walletAddress);

      if (nativeBalance < difference) {
        throw new DomaOrderbookError(
          DomaOrderbookErrorCode.INSUFFICIENT_NATIVE_BALANCE,
          `Insufficient native balance to cover wrapper currency conversion`,
        );
      }

      return {
        type: 'conversion',
        transactionMethods: createWrapperCurrencyDepositTransaction(
          this.signer,
          wrapperCurrency,
          difference,
        ),
      };
    }

    return null;
  }

  private async handleSingleOffer(
    item: OfferItem,
    walletAddress: string,
    seaport: Seaport,
    fees: Fee[],
    params: CreateOfferParams,
  ): Promise<CreateOfferResult> {
    try {
      const endTime = Math.floor(
        (Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND,
      );
      const conduitKey = getOrderbookConduitKey(params.orderbook);

      const createOrderInput = buildOfferOrderInput(
        item,
        walletAddress,
        endTime,
        fees,
        getOrderbookZone(params.orderbook, parseChainId(this.chainId)),
        conduitKey,
      );

      const actions: BlockchainActions[] = [];

      // Check approval actions
      const approvalActions = await this.getApprovalActions(
        walletAddress,
        createOrderInput,
        this.signer,
        false,
        conduitKey,
      );
      actions.push(...approvalActions);

      // Wrapper Currency conversion action
      const supportedCurrency = await this.validateCurrency([item], params.orderbook);
      if (supportedCurrency.nativeWrapper) {
        const wrapperCurrencyConversionAction = await this.createWrapperConversionAction(
          [item],
          walletAddress,
          supportedCurrency.contractAddress,
        );
        if (wrapperCurrencyConversionAction) {
          actions.push(wrapperCurrencyConversionAction);
        }
      }

      // Build order actions
      const orderUseCase = await seaport.createOrder(createOrderInput, walletAddress);
      actions.push(...orderUseCase.actions);

      const result = await this.executeBlockchainOperation<OrderWithCounter>(actions);

      const offerResponse = await this.apiClient.createOffer({
        signature: result.signature,
        orderbook: params.orderbook,
        chainId: this.chainId,
        parameters: result.parameters,
        cancelExisting: params.cancelExisting,
      });

      return {
        orders: [{ orderId: offerResponse.orderId, orderData: result }],
      };
    } catch (error) {
      throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.OFFER_CREATION_FAILED);
    }
  }

  private async handleBulkOffer(
    items: OfferItem[],
    walletAddress: string,
    seaport: Seaport,
    fees: Fee[],
    params: CreateOfferParams,
  ): Promise<CreateOfferResult> {
    try {
      const conduitKey = getOrderbookConduitKey(params.orderbook);
      const actions: BlockchainActions[] = [];

      // Build all order inputs first
      const createOrderInputs = items.map((item) => {
        const endTime = Math.floor(
          (Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND,
        );

        return buildOfferOrderInput(
          item,
          walletAddress,
          endTime,
          fees,
          getOrderbookZone(params.orderbook, parseChainId(this.chainId)),
          conduitKey,
        );
      });

      // Check approval actions for all orders
      for (const createOrderInput of createOrderInputs) {
        const approvalActions = await this.getApprovalActions(
          walletAddress,
          createOrderInput,
          this.signer,
          false,
          conduitKey,
        );
        actions.push(...approvalActions);
      }

      // Wrapper Currency conversion action
      const supportedCurrency = await this.validateCurrency(items, params.orderbook);
      if (supportedCurrency.nativeWrapper) {
        const wrapperCurrencyConversionAction = await this.createWrapperConversionAction(
          items,
          walletAddress,
          supportedCurrency.contractAddress,
        );
        if (wrapperCurrencyConversionAction) {
          actions.push(wrapperCurrencyConversionAction);
        }
      }

      // Create bulk orders
      const bulkOrderUseCase = await seaport.createBulkOrders(createOrderInputs, walletAddress);
      actions.push(...bulkOrderUseCase.actions);

      const results = await this.executeBlockchainOperation<OrderWithCounter[]>(actions);

      const offerResponse = await this.apiClient.createBulkOffer({
        orders: results.map((result) => ({
          signature: result.signature,
          parameters: result.parameters,
        })),
        orderbook: params.orderbook,
        chainId: this.chainId,
      });

      return {
        orders: offerResponse.orders.map((order: CreateOfferResponse) => {
          return {
            orderId: order.orderId,
            orderData: {
              signature: order.signature,
              parameters: order.orderData,
            },
          };
        }),
        errors: offerResponse.errors,
      };
    } catch (error) {
      throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.OFFER_CREATION_FAILED);
    }
  }

  private async getApprovalActions(
    offerer: string,
    order: CreateOrderInput,
    provider: JsonRpcProvider | Signer,
    exactApproval: boolean,
    conduitKey?: string,
  ): Promise<BlockchainActions[]> {
    const mappedOfferItems = order.offer.map(mapInputItemToOfferItem);

    // For NO_CONDUIT, the operator is the Seaport contract address itself
    const operator = conduitKey || (await this.seaport.contract.getAddress());

    const balancesAndApprovals = await getBalancesAndApprovals({
      owner: offerer,
      items: mappedOfferItems,
      criterias: [],
      provider: provider as JsonRpcProvider,
      operator,
    });

    const insufficientApprovals = validateOfferBalancesAndApprovals({
      offer: mappedOfferItems,
      criterias: [],
      balancesAndApprovals,
      throwOnInsufficientBalances: false,
      operator,
    });

    return getApprovalActions(insufficientApprovals, exactApproval, provider as Signer);
  }
}
