import { DomaOrderbookError, DomaOrderbookErrorCode } from './errors';
const getActionDescription = (actionType) => {
    switch (actionType) {
        case 'create':
            return 'Creating order';
        case 'createBulk':
            return 'Creating bulk orders';
        case 'exchange':
            return 'Fulfilling order';
        case 'approval':
            return 'Approving token';
        case 'conversion':
            return 'Converting token';
        case 'cancelOrder':
            return 'Canceling order (on-chain)';
        case 'offChainCancel':
            return 'Canceling order (off-chain)';
        default:
            return `Executing ${actionType}`;
    }
};
export const prepareActionSteps = (actions) => {
    return actions.map((action) => {
        if (action.type === 'approval') {
            const approvalAction = action;
            return {
                status: 'incomplete',
                kind: 'transaction',
                action: approvalAction.type,
                description: getActionDescription(action.type),
            };
        }
        if (action.type === 'create' ||
            action.type === 'createBulk' ||
            action.type === 'exchange' ||
            action.type === 'conversion' ||
            action.type === 'cancelOrder' ||
            action.type === 'offChainCancel') {
            return {
                status: 'incomplete',
                kind: action.type === 'create' ||
                    action.type === 'createBulk' ||
                    action.type === 'offChainCancel'
                    ? 'signature'
                    : 'transaction',
                action: action.type,
                description: getActionDescription(action.type),
            };
        }
        throw new Error(`Unsupported action type: ${action}`);
    });
};
export class Progress {
    constructor(steps, progressCallback) {
        this.items = [];
        this.currentStepIndex = 0;
        this.totalSteps = 0;
        this.items = steps;
        this.totalSteps = steps.length;
        this.progressCallback = progressCallback;
    }
    updateStep(index, updateInfo) {
        if (index < 0 || index >= this.items.length) {
            throw new Error(`Step index out of bounds: ${index}`);
        }
        this.items[index] = {
            ...this.items[index],
            ...updateInfo,
        };
        this.notifyProgress();
    }
    completeStep(index, updateInfo) {
        if (index < 0 || index >= this.items.length) {
            throw new Error(`Step index out of bounds: ${index}`);
        }
        this.items[index] = {
            ...this.items[index],
            ...(updateInfo || {}),
            status: 'complete',
            progressState: this.items[index].kind === 'signature' ? undefined : 'confirmed',
        };
        // Auto-advance to next step
        if (index < this.totalSteps - 1) {
            this.currentStepIndex = index + 1;
        }
        this.notifyProgress();
    }
    setTransactionSubmitted(index, txHash, chainId) {
        if (index < 0 || index >= this.items.length) {
            throw new Error(`Step index out of bounds: ${index}`);
        }
        const txInfo = { txHash, chainId };
        this.items[index] = {
            ...this.items[index],
            progressState: 'submitted',
            txHashes: this.items[index].txHashes ? [...this.items[index].txHashes, txInfo] : [txInfo],
        };
        this.notifyProgress();
    }
    notifyProgress() {
        if (this.progressCallback) {
            this.progressCallback([...this.items]);
        }
    }
    failStep(index, error) {
        if (index < 0 || index >= this.items.length) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.INVALID_PARAMETERS, `Step index out of bounds: ${index}`);
        }
        this.items[index] = {
            ...this.items[index],
            status: 'error',
            error: error instanceof Error ? error.message : String(error),
            errorData: error,
        };
        this.notifyProgress();
    }
    isComplete() {
        return this.items.every((step) => step.status === 'complete');
    }
}
export const executeAllActions = async (actions, options) => {
    const { onProgress } = options || {};
    if (!actions?.length) {
        throw new DomaOrderbookError(DomaOrderbookErrorCode.INVALID_PARAMETERS, 'No actions provided');
    }
    const preparedSteps = prepareActionSteps(actions);
    const progress = new Progress(preparedSteps, onProgress);
    let finalResult = null;
    // Process all actions
    for (let i = 0; i < actions.length; i++) {
        const action = actions[i];
        const isFinalAction = i === actions.length - 1;
        progress.updateStep(i, { progressState: 'pending' });
        try {
            // signature-based actions
            if (action.type === 'create') {
                const createResult = await action.createOrder();
                progress.completeStep(i);
                if (isFinalAction) {
                    finalResult = createResult;
                }
            }
            else if (action.type === 'createBulk') {
                const bulkResult = await action.createBulkOrders();
                progress.completeStep(i);
                if (isFinalAction) {
                    finalResult = bulkResult;
                }
            }
            else if (action.type === 'offChainCancel') {
                const cancelResult = await action.createCancelSignature();
                progress.completeStep(i);
                if (isFinalAction) {
                    finalResult = cancelResult;
                }
            }
            // transaction-based actions
            else {
                const tx = await action.transactionMethods.transact();
                if (tx) {
                    progress.setTransactionSubmitted(i, tx.hash, Number(tx.chainId));
                }
                const txResult = await tx.wait();
                progress.completeStep(i);
                if (isFinalAction) {
                    finalResult = txResult;
                }
            }
        }
        catch (error) {
            progress.failStep(i, error);
            const actionType = action.type;
            const errorContext = {
                actionType,
                actionIndex: i,
                progress: progress.items,
            };
            if (actionType === 'approval') {
                throw new DomaOrderbookError(DomaOrderbookErrorCode.SEAPORT_APPROVAL_FAILED, `Failed to approve ${action.token || 'token'}`, error, errorContext);
            }
            if (actionType === 'create' || actionType === 'createBulk') {
                throw new DomaOrderbookError(DomaOrderbookErrorCode.SEAPORT_SIGNATURE_FAILED, `Failed to ${actionType}`, error, errorContext);
            }
            if (actionType === 'offChainCancel') {
                throw new DomaOrderbookError(DomaOrderbookErrorCode.OFFCHAIN_CANCEL_ORDER_FAILED, `Failed to ${actionType}`, error, errorContext);
            }
            if (actionType === 'exchange' || actionType === 'cancelOrder') {
                throw new DomaOrderbookError(DomaOrderbookErrorCode.SEAPORT_TRANSACTION_FAILED, `Failed to ${actionType}`, error, errorContext);
            }
            if (actionType === 'conversion') {
                throw new DomaOrderbookError(DomaOrderbookErrorCode.TOKEN_CONVERSION_FAILED, `Failed to ${actionType}`, error, errorContext);
            }
            throw new DomaOrderbookError(DomaOrderbookErrorCode.UNKNOWN_ERROR, `Failed to execute ${actionType}`, error, errorContext);
        }
    }
    if (!finalResult) {
        throw new DomaOrderbookError(DomaOrderbookErrorCode.UNKNOWN_ERROR, 'Final result not found', null, {
            progress: progress.items,
        });
    }
    return finalResult;
};
