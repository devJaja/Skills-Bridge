import { SeaportOperationHandler } from '../seaport-operation.handler';
import { DomaOrderbookError, DomaOrderbookErrorCode } from '../../errors';
import { HOURS_IN_DAY, MILLISECONDS_IN_SECOND, MINUTES_IN_HOUR, SECONDS_IN_MINUTE, } from '../../utils/date.utils';
import { buildListingOrderInput, prepareFees } from '../../utils/seaport-order.utils';
import { getOrderbookConduitKey, getOrderbookZone } from '../../utils/orderbook-zone.utils';
import { parseChainId } from '../../utils/chain.utils';
export class ListingHandler extends SeaportOperationHandler {
    constructor() {
        super(...arguments);
        this.DEFAULT_LIST_DURATION = HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND;
    }
    async execute(params) {
        try {
            const { items, marketplaceFees } = params;
            this.validateInputs(items);
            await this.validateCurrency(items, params.orderbook);
            const walletAddress = await this.getWalletAddress();
            const fees = prepareFees(marketplaceFees);
            if (items.length === 1) {
                return await this.handleSingleListing(items[0], walletAddress, this.seaport, fees, params);
            }
            return await this.handleBulkListing(items, walletAddress, this.seaport, fees, params);
        }
        catch (error) {
            throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.LISTING_CREATION_FAILED, {
                chainId: this.chainId,
                params,
            });
        }
    }
    validateInputs(items) {
        if (!items?.length) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.INVALID_PARAMETERS, 'At least one item must be provided');
        }
    }
    async validateCurrency(items, orderbook) {
        const currencyContractAddress = items[0].currencyContractAddress;
        // we assume native currency
        if (currencyContractAddress === undefined) {
            return;
        }
        // check if all currencies are same
        const sameCurrency = items.every((item) => item.currencyContractAddress === currencyContractAddress);
        if (!sameCurrency) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.CURRENCY_NOT_SAME, `All currencies must be the same`);
        }
        // Load supported currencies
        const itemContractAddress = items[0].contract;
        const currenciesResponse = await this.apiClient.getSupportedCurrencies({
            contractAddress: itemContractAddress,
            chainId: this.chainId,
            orderbook: orderbook,
        });
        const supportedCurrency = currenciesResponse.currencies.find((currency) => currency.contractAddress === currencyContractAddress);
        if (!supportedCurrency) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.CURRENCY_NOT_SUPPORTED, `Currency not supported`);
        }
    }
    async handleSingleListing(item, walletAddress, seaport, fees, params) {
        const endTime = Math.floor((Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND);
        const createOrderInput = buildListingOrderInput(item, walletAddress, endTime, fees, getOrderbookZone(params.orderbook, parseChainId(this.chainId)), getOrderbookConduitKey(params.orderbook));
        const orderUseCase = await seaport.createOrder(createOrderInput, walletAddress);
        const result = await this.executeBlockchainOperation(orderUseCase.actions);
        const listingResponse = await this.apiClient.createListing({
            signature: result.signature,
            orderbook: params.orderbook,
            chainId: this.chainId,
            parameters: result.parameters,
            cancelExisting: params.cancelExisting,
        });
        return {
            orders: [{ orderId: listingResponse.orderId, orderData: result }],
        };
    }
    async handleBulkListing(items, walletAddress, seaport, fees, params) {
        const createOrderInputs = items.map((item) => {
            const endTime = Math.floor((Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND);
            return buildListingOrderInput(item, walletAddress, endTime, fees, getOrderbookZone(params.orderbook, parseChainId(this.chainId)), getOrderbookConduitKey(params.orderbook));
        });
        const bulkOrderUseCase = await seaport.createBulkOrders(createOrderInputs, walletAddress);
        const results = await this.executeBlockchainOperation(bulkOrderUseCase.actions);
        const listingResponse = await this.apiClient.createBulkListing({
            orders: results.map((result) => ({
                signature: result.signature,
                parameters: result.parameters,
            })),
            orderbook: params.orderbook,
            chainId: this.chainId,
        });
        return {
            orders: listingResponse.orders.map((order) => {
                return {
                    orderId: order.orderId,
                    orderData: {
                        signature: order.signature,
                        parameters: order.orderData,
                    },
                };
            }),
            errors: listingResponse.errors,
        };
    }
}
