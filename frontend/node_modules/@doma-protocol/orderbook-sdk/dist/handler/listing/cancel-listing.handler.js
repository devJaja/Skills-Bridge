import { SeaportOperationHandler } from '../seaport-operation.handler';
import { DomaOrderbookError, DomaOrderbookErrorCode } from '../../errors';
import { createOffChainCancelAction } from '../actions/offchain-cancel.action';
import { parseChainId } from '../../utils/chain.utils';
export class CancelListingHandler extends SeaportOperationHandler {
    async validateAndGetListing(orderId, fulFillerAddress) {
        const listing = await this.apiClient.getListing({
            orderId,
            fulFillerAddress,
        });
        if (!listing) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.ORDER_NOT_FOUND, 'Listing not found');
        }
        return listing;
    }
    async cancelOffChain(orderId) {
        const seaportAddress = await this.seaport.contract.getAddress();
        // Create the cancel action
        const offchainCancelAction = createOffChainCancelAction(this.signer, orderId, seaportAddress, parseChainId(this.chainId));
        const cancelResult = await this.executeBlockchainOperation([
            offchainCancelAction,
        ]);
        await this.apiClient.cancelListing({
            orderId: orderId,
            signature: cancelResult.signature,
        });
        return {
            transactionHash: null,
            status: 'success',
            gasUsed: 0n,
            gasPrice: 0n,
        };
    }
    async cancelOnChain(listing) {
        // Use Seaport to cancel the order on-chain
        const cancelOrdersAction = this.seaport.cancelOrders([
            {
                ...listing.order.parameters,
            },
        ]);
        // Execute the cancellation transaction
        const result = await this.executeBlockchainOperation([
            {
                type: 'cancelOrder',
                transactionMethods: cancelOrdersAction,
            },
        ]);
        return {
            gasPrice: result.gasPrice,
            gasUsed: result.gasUsed,
            transactionHash: result.hash,
            status: result.status === 1 ? 'success' : 'reverted',
        };
    }
    async execute(params) {
        try {
            const walletAddress = await this.signer.getAddress();
            const listing = await this.validateAndGetListing(params.orderId, walletAddress);
            if (params.cancellationType === 'off-chain') {
                return await this.cancelOffChain(params.orderId);
            }
            return await this.cancelOnChain(listing);
        }
        catch (error) {
            throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.LISTING_CANCELLATION_FAILED, {
                chainId: this.chainId,
                params,
            });
        }
    }
}
