import { SeaportOperationHandler } from '../seaport-operation.handler';
import { DomaOrderbookError, DomaOrderbookErrorCode } from '../../errors';
import { HOURS_IN_DAY, MILLISECONDS_IN_SECOND, MINUTES_IN_HOUR, SECONDS_IN_MINUTE, } from '../../utils/date.utils';
import { buildOfferOrderInput, prepareFees } from '../../utils/seaport-order.utils';
import { Weth__factory } from '../../contracts';
import { createWrapperCurrencyDepositTransaction, } from '../actions/weth.action';
import { mapInputItemToOfferItem } from '@opensea/seaport-js/lib/utils/order';
import { getBalancesAndApprovals, validateOfferBalancesAndApprovals, } from '@opensea/seaport-js/lib/utils/balanceAndApprovalCheck';
import { getApprovalActions } from '@opensea/seaport-js/lib/utils/approval';
import { parseChainId } from '../../utils/chain.utils';
import { getOrderbookConduitKey, getOrderbookZone } from '../../utils/orderbook-zone.utils';
export class CreateOfferHandler extends SeaportOperationHandler {
    constructor() {
        super(...arguments);
        this.DEFAULT_LIST_DURATION = HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND;
    }
    async execute(params) {
        try {
            const { items, marketplaceFees } = params;
            this.validateInputs(items);
            const walletAddress = await this.getWalletAddress();
            await this.validateBalances(items, walletAddress, params.orderbook);
            const fees = prepareFees(marketplaceFees);
            if (items.length === 1) {
                return await this.handleSingleOffer(items[0], walletAddress, this.seaport, fees, params);
            }
            return await this.handleBulkOffer(items, walletAddress, this.seaport, fees, params);
        }
        catch (error) {
            throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.OFFER_CREATION_FAILED, {
                chainId: this.chainId,
                params,
            });
        }
    }
    validateInputs(items) {
        if (!items?.length) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.INVALID_PARAMETERS, 'At least one item must be provided');
        }
    }
    async validateBalances(items, walletAddress, orderbook) {
        const supportedCurrency = await this.validateCurrency(items, orderbook);
        // Group items by currency
        const itemsByCurrency = new Map();
        for (const item of items) {
            const currency = item.currencyContractAddress.toLowerCase();
            if (!itemsByCurrency.has(currency)) {
                itemsByCurrency.set(currency, []);
            }
            itemsByCurrency.get(currency).push(item);
        }
        for (const [currencyAddress, currencyItems] of itemsByCurrency) {
            // Get the maximum amount needed (for offers, we need the max, not the sum)
            const maxAmountNeeded = currencyItems.reduce((max, item) => {
                const itemPrice = BigInt(item.price);
                return itemPrice > max ? itemPrice : max;
            }, 0n);
            // Check if this is a native wrapper currency
            if (supportedCurrency.nativeWrapper &&
                currencyAddress.toLowerCase() === supportedCurrency.contractAddress.toLowerCase()) {
                // For native wrapper, check combined native + wrapper balance
                await this.validateNativeWrapperBalance(currencyAddress, maxAmountNeeded, walletAddress);
            }
            else {
                // For regular ERC20, just check token balance
                await this.validateTokenBalance(currencyAddress, maxAmountNeeded, walletAddress);
            }
        }
    }
    async validateNativeWrapperBalance(wrapperAddress, amountNeeded, walletAddress) {
        const wrapperContract = Weth__factory.connect(wrapperAddress, this.signer);
        const wrapperBalance = await wrapperContract.balanceOf(walletAddress);
        if (wrapperBalance >= amountNeeded) {
            return;
        }
        const difference = amountNeeded - wrapperBalance;
        const nativeBalance = await this.signer.provider.getBalance(walletAddress);
        if (nativeBalance < difference) {
            const totalAvailable = wrapperBalance + nativeBalance;
            throw new DomaOrderbookError(DomaOrderbookErrorCode.INSUFFICIENT_BALANCE, `Insufficient balance: need ${amountNeeded.toString()} but only have ${totalAvailable.toString()} (${wrapperBalance.toString()} wrapped + ${nativeBalance.toString()} native)`, {
                required: amountNeeded.toString(),
                wrapperBalance: wrapperBalance.toString(),
                nativeBalance: nativeBalance.toString(),
                totalAvailable: totalAvailable.toString(),
            });
        }
    }
    async validateTokenBalance(tokenAddress, amountNeeded, walletAddress) {
        // Using Weth__factory works for any ERC20 since balanceOf is standard
        const tokenContract = Weth__factory.connect(tokenAddress, this.signer);
        const balance = await tokenContract.balanceOf(walletAddress);
        if (balance < amountNeeded) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.INSUFFICIENT_BALANCE, `Insufficient token balance: need ${amountNeeded.toString()} but only have ${balance.toString()}`, {
                tokenAddress,
                required: amountNeeded.toString(),
                available: balance.toString(),
            });
        }
    }
    async validateCurrency(items, orderbook) {
        const currencyContractAddress = items[0].currencyContractAddress;
        // check if all currencies are same
        const sameCurrency = items.every((item) => item.currencyContractAddress.toLowerCase() === currencyContractAddress.toLowerCase());
        if (!sameCurrency) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.CURRENCY_NOT_SAME, `All currencies must be the same`);
        }
        // Load supported currencies
        const itemContractAddress = items[0].contract;
        const currenciesResponse = await this.apiClient.getSupportedCurrencies({
            contractAddress: itemContractAddress,
            chainId: this.chainId,
            orderbook: orderbook,
        });
        const supportedCurrency = currenciesResponse.currencies.find((currency) => currency.contractAddress.toLowerCase() === currencyContractAddress.toLowerCase());
        if (!supportedCurrency) {
            throw new DomaOrderbookError(DomaOrderbookErrorCode.CURRENCY_NOT_SUPPORTED, `Currency not supported`);
        }
        return supportedCurrency;
    }
    async createWrapperConversionAction(items, walletAddress, wrapperContractAddress) {
        const wrapperItems = items.filter((item) => item.currencyContractAddress.toLowerCase() === wrapperContractAddress.toLowerCase());
        // We will assume WETH-Contract as template for wrapper currency
        const wrapperCurrency = Weth__factory.connect(wrapperContractAddress, this.signer);
        const wrapperCurrencyBalance = await wrapperCurrency.balanceOf(walletAddress);
        // Find the highest Wrapper Currency amount needed (for offers, we take the max, not sum)
        const maxWrapperCurrencyNeeded = wrapperItems.reduce((max, item) => BigInt(item.price) > BigInt(max.price) ? item : max);
        const difference = BigInt(maxWrapperCurrencyNeeded.price) - wrapperCurrencyBalance;
        if (difference > 0n) {
            // Balance should already be validated, but double-check
            const nativeBalance = await this.signer.provider.getBalance(walletAddress);
            if (nativeBalance < difference) {
                throw new DomaOrderbookError(DomaOrderbookErrorCode.INSUFFICIENT_NATIVE_BALANCE, `Insufficient native balance to cover wrapper currency conversion`);
            }
            return {
                type: 'conversion',
                transactionMethods: createWrapperCurrencyDepositTransaction(this.signer, wrapperCurrency, difference),
            };
        }
        return null;
    }
    async handleSingleOffer(item, walletAddress, seaport, fees, params) {
        try {
            const endTime = Math.floor((Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND);
            const conduitKey = getOrderbookConduitKey(params.orderbook);
            const createOrderInput = buildOfferOrderInput(item, walletAddress, endTime, fees, getOrderbookZone(params.orderbook, parseChainId(this.chainId)), conduitKey);
            const actions = [];
            // Check approval actions
            const approvalActions = await this.getApprovalActions(walletAddress, createOrderInput, this.signer, false, conduitKey);
            actions.push(...approvalActions);
            // Wrapper Currency conversion action
            const supportedCurrency = await this.validateCurrency([item], params.orderbook);
            if (supportedCurrency.nativeWrapper) {
                const wrapperCurrencyConversionAction = await this.createWrapperConversionAction([item], walletAddress, supportedCurrency.contractAddress);
                if (wrapperCurrencyConversionAction) {
                    actions.push(wrapperCurrencyConversionAction);
                }
            }
            // Build order actions
            const orderUseCase = await seaport.createOrder(createOrderInput, walletAddress);
            actions.push(...orderUseCase.actions);
            const result = await this.executeBlockchainOperation(actions);
            const offerResponse = await this.apiClient.createOffer({
                signature: result.signature,
                orderbook: params.orderbook,
                chainId: this.chainId,
                parameters: result.parameters,
                cancelExisting: params.cancelExisting,
            });
            return {
                orders: [{ orderId: offerResponse.orderId, orderData: result }],
            };
        }
        catch (error) {
            throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.OFFER_CREATION_FAILED);
        }
    }
    async handleBulkOffer(items, walletAddress, seaport, fees, params) {
        try {
            const conduitKey = getOrderbookConduitKey(params.orderbook);
            const actions = [];
            // Build all order inputs first
            const createOrderInputs = items.map((item) => {
                const endTime = Math.floor((Date.now() + (item.duration || this.DEFAULT_LIST_DURATION)) / MILLISECONDS_IN_SECOND);
                return buildOfferOrderInput(item, walletAddress, endTime, fees, getOrderbookZone(params.orderbook, parseChainId(this.chainId)), conduitKey);
            });
            // Check approval actions for all orders
            for (const createOrderInput of createOrderInputs) {
                const approvalActions = await this.getApprovalActions(walletAddress, createOrderInput, this.signer, false, conduitKey);
                actions.push(...approvalActions);
            }
            // Wrapper Currency conversion action
            const supportedCurrency = await this.validateCurrency(items, params.orderbook);
            if (supportedCurrency.nativeWrapper) {
                const wrapperCurrencyConversionAction = await this.createWrapperConversionAction(items, walletAddress, supportedCurrency.contractAddress);
                if (wrapperCurrencyConversionAction) {
                    actions.push(wrapperCurrencyConversionAction);
                }
            }
            // Create bulk orders
            const bulkOrderUseCase = await seaport.createBulkOrders(createOrderInputs, walletAddress);
            actions.push(...bulkOrderUseCase.actions);
            const results = await this.executeBlockchainOperation(actions);
            const offerResponse = await this.apiClient.createBulkOffer({
                orders: results.map((result) => ({
                    signature: result.signature,
                    parameters: result.parameters,
                })),
                orderbook: params.orderbook,
                chainId: this.chainId,
            });
            return {
                orders: offerResponse.orders.map((order) => {
                    return {
                        orderId: order.orderId,
                        orderData: {
                            signature: order.signature,
                            parameters: order.orderData,
                        },
                    };
                }),
                errors: offerResponse.errors,
            };
        }
        catch (error) {
            throw DomaOrderbookError.fromError(error, DomaOrderbookErrorCode.OFFER_CREATION_FAILED);
        }
    }
    async getApprovalActions(offerer, order, provider, exactApproval, conduitKey) {
        const mappedOfferItems = order.offer.map(mapInputItemToOfferItem);
        // For NO_CONDUIT, the operator is the Seaport contract address itself
        const operator = conduitKey || (await this.seaport.contract.getAddress());
        const balancesAndApprovals = await getBalancesAndApprovals({
            owner: offerer,
            items: mappedOfferItems,
            criterias: [],
            provider: provider,
            operator,
        });
        const insufficientApprovals = validateOfferBalancesAndApprovals({
            offer: mappedOfferItems,
            criterias: [],
            balancesAndApprovals,
            throwOnInsufficientBalances: false,
            operator,
        });
        return getApprovalActions(insufficientApprovals, exactApproval, provider);
    }
}
