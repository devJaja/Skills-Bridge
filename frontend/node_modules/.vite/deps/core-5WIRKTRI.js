import {
  CaipNetworksUtil,
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  LoggerUtil,
  PresetsUtil,
  ProviderUtil,
  WalletUtil
} from "./chunk-3XDCJVPW.js";
import {
  AccountController,
  AlertController,
  ApiController,
  AssetUtil,
  BlockchainApiController,
  C,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EnsController,
  EventsController,
  G,
  M,
  ModalController,
  NetworkUtil,
  OnRampController,
  OptionsController,
  ParseUtil,
  PublicStateController,
  Q,
  RouterController,
  SIWXUtil,
  SendController,
  SnackController,
  StorageUtil,
  ThemeController,
  Xo,
  Y,
  er,
  ir,
  re,
  setColorTheme,
  setThemeVariables,
  sr,
  tr,
  ue,
  xt,
  zi
} from "./chunk-ZKO52WZY.js";
import {
  fromString,
  toString
} from "./chunk-AGC3H26O.js";
import "./chunk-543AJ33O.js";
import "./chunk-YEFHVMA2.js";
import "./chunk-XSJWZTXG.js";
import {
  LruMap,
  checksumAddress,
  defineFormatter,
  hexToBigInt,
  hexToNumber,
  isHex,
  keccak256,
  numberToHex,
  toHex as toHex2
} from "./chunk-MTHNE2EW.js";
import "./chunk-IPZCLI2Y.js";
import "./chunk-4RGWLAF4.js";
import "./chunk-LQH6MSRX.js";
import {
  E,
  esm_default,
  esm_exports,
  f2 as f,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  import_pino,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  k,
  o,
  payloadId,
  require_cjs,
  require_cjs2,
  require_cjs3,
  y
} from "./chunk-Q666IA43.js";
import "./chunk-ANJCMEYS.js";
import {
  require_events
} from "./chunk-2YULO2GZ.js";
import "./chunk-DF2FOQV5.js";
import "./chunk-7LMDMJQJ.js";
import "./chunk-6WACAMLS.js";
import "./chunk-IDC4ZXGW.js";
import "./chunk-SYLL3SQI.js";
import "./chunk-KASMAJTU.js";
import "./chunk-PFTOPCXV.js";
import "./chunk-OWINAXAL.js";
import "./chunk-FZS6HOUP.js";
import {
  toHex
} from "./chunk-WX5QCCWZ.js";
import "./chunk-F3M2F5R6.js";
import "./chunk-5UBV5ZHI.js";
import {
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var T = Object.defineProperty;
var k2 = (e, s, r) => s in e ? T(e, s, { enumerable: true, configurable: true, writable: true, value: r }) : e[s] = r;
var i = (e, s, r) => k2(e, typeof s != "symbol" ? s + "" : s, r);
var J = class {
  constructor(s) {
    this.opts = s, i(this, "protocol", "wc"), i(this, "version", 2);
  }
};
var V = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash, signature }) {
  const hashHex = isHex(hash) ? hash : toHex2(hash);
  const { secp256k1: secp256k12 } = await import("./secp256k1-E45JT266.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r, s, v: v2, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v2);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex2(signature);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }));
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var ae = ":";
function Ne(t) {
  const [e, n2] = t.split(ae);
  return { namespace: e, reference: n2 };
}
function ue2(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Zo = Object.defineProperty;
var Yo = Object.defineProperties;
var Go = Object.getOwnPropertyDescriptors;
var Tn = Object.getOwnPropertySymbols;
var Wo = Object.prototype.hasOwnProperty;
var Xo2 = Object.prototype.propertyIsEnumerable;
var Rn = (t, e, n2) => e in t ? Zo(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var _n = (t, e) => {
  for (var n2 in e || (e = {})) Wo.call(e, n2) && Rn(t, n2, e[n2]);
  if (Tn) for (var n2 of Tn(e)) Xo2.call(e, n2) && Rn(t, n2, e[n2]);
  return t;
};
var Jo = (t, e) => Yo(t, Go(e));
var $n = "ReactNative";
var Y2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
function _e() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function pt() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === $n;
}
function Tt() {
  return !_e() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function xt2() {
  return pt() ? Y2.reactNative : _e() ? Y2.node : Tt() ? Y2.browser : Y2.unknown;
}
function oi(t) {
  var e, n2;
  const r = Pn();
  try {
    return t != null && t.url && r.url && new URL(t.url).host !== new URL(r.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`), t.url = r.url), (e = t?.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((o2) => o2 !== "")), Jo(_n(_n({}, r), t), { url: t?.url || r.url, name: t?.name || r.name, description: t?.description || r.description, icons: (n2 = t?.icons) != null && n2.length && t.icons.length > 0 ? t.icons : r.icons });
  } catch (o2) {
    return console.warn("Error populating app metadata", o2), t || r;
  }
}
function Pn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function gt(t, e) {
  return t.filter((n2) => e.includes(n2)).length === t.length;
}
function gi(t = import_time.FIVE_MINUTES, e) {
  const n2 = (0, import_time.toMiliseconds)(t || import_time.FIVE_MINUTES);
  let r, o2, i2, s;
  return { resolve: (c2) => {
    i2 && r && (clearTimeout(i2), r(c2), s = Promise.resolve(c2));
  }, reject: (c2) => {
    i2 && o2 && (clearTimeout(i2), o2(c2));
  }, done: () => new Promise((c2, a) => {
    if (s) return c2(s);
    i2 = setTimeout(() => {
      const u2 = new Error(e);
      s = Promise.reject(u2), a(u2);
    }, n2), r = c2, o2 = a;
  }) };
}
function bi(t) {
  const [e, n2] = t.split(":"), r = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n2 == "string") r.topic = n2;
  else if (e === "id" && Number.isInteger(Number(n2))) r.id = Number(n2);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n2}`);
  return r;
}
function Ei(t, e) {
  return (0, import_time.fromMiliseconds)((e || Date.now()) + (0, import_time.toMiliseconds)(t));
}
function vi(t) {
  return Date.now() >= (0, import_time.toMiliseconds)(t);
}
function xi(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function ot(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Si({ id: t, topic: e, wcDeepLink: n2 }) {
  var r;
  try {
    if (!n2) return;
    const o2 = typeof n2 == "string" ? JSON.parse(n2) : n2, i2 = o2?.href;
    if (typeof i2 != "string") return;
    const s = Kn(i2, t, e), c2 = xt2();
    if (c2 === Y2.browser) {
      if (!((r = (0, import_window_getters.getDocument)()) != null && r.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Fn(s);
    } else c2 === Y2.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (o2) {
    console.error(o2);
  }
}
function Kn(t, e, n2) {
  const r = `requestId=${e}&sessionTopic=${n2}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let o2 = `${t}`;
  if (t.startsWith("https://t.me")) {
    const i2 = t.includes("?") ? "&startapp=" : "?startapp=";
    o2 = `${o2}${i2}${Yn(r, true)}`;
  } else o2 = `${o2}/wc?${r}`;
  return o2;
}
function Fn(t) {
  let e = "_self";
  Zn() ? e = "_top" : (zn() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function Oi(t, e) {
  let n2 = "";
  try {
    if (Tt() && (n2 = localStorage.getItem(e), n2)) return n2;
    n2 = await t.getItem(e);
  } catch (r) {
    console.error(r);
  }
  return n2;
}
function Ai(t, e) {
  if (!t.includes(e)) return null;
  const n2 = t.split(/([&,?,=])/), r = n2.indexOf(e);
  return n2[r + 2];
}
function Ii() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function zn() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Zn() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function Yn(t, e = false) {
  const n2 = Buffer.from(t).toString("base64");
  return e ? n2.replace(/[=]/g, "") : n2;
}
function Wt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Ui(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Xt(t, ...e) {
  if (!Ui(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Ce(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Wt(t.outputLen), Wt(t.blockLen);
}
function Rt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Gn(t, e) {
  Xt(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
var le = BigInt(2 ** 32 - 1);
var Wn = BigInt(32);
function Ti(t, e = false) {
  return e ? { h: Number(t & le), l: Number(t >> Wn & le) } : { h: Number(t >> Wn & le) | 0, l: Number(t & le) | 0 };
}
function Ri(t, e = false) {
  let n2 = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let o2 = 0; o2 < t.length; o2++) {
    const { h: i2, l: s } = Ti(t[o2], e);
    [n2[o2], r[o2]] = [i2, s];
  }
  return [n2, r];
}
var _i = (t, e, n2) => t << n2 | e >>> 32 - n2;
var $i = (t, e, n2) => e << n2 | t >>> 32 - n2;
var Li = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var ji = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
var _t = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ci(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Pe(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function ct(t, e) {
  return t << 32 - e | t >>> e;
}
var Xn = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Pi(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Jn(t) {
  for (let e = 0; e < t.length; e++) t[e] = Pi(t[e]);
}
function ki(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function $t(t) {
  return typeof t == "string" && (t = ki(t)), Xt(t), t;
}
function Vi(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const o2 = t[r];
    Xt(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r = 0, o2 = 0; r < t.length; r++) {
    const i2 = t[r];
    n2.set(i2, o2), o2 += i2.length;
  }
  return n2;
}
var ke = class {
  clone() {
    return this._cloneInto();
  }
};
function Qn(t) {
  const e = (r) => t().update($t(r)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function Lt(t = 32) {
  if (_t && typeof _t.getRandomValues == "function") return _t.getRandomValues(new Uint8Array(t));
  if (_t && typeof _t.randomBytes == "function") return _t.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
var tr2 = [];
var er2 = [];
var nr = [];
var Mi = BigInt(0);
var Jt = BigInt(1);
var Di = BigInt(2);
var Hi = BigInt(7);
var qi = BigInt(256);
var Ki = BigInt(113);
for (let t = 0, e = Jt, n2 = 1, r = 0; t < 24; t++) {
  [n2, r] = [r, (2 * n2 + 3 * r) % 5], tr2.push(2 * (5 * r + n2)), er2.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = Mi;
  for (let i2 = 0; i2 < 7; i2++) e = (e << Jt ^ (e >> Hi) * Ki) % qi, e & Di && (o2 ^= Jt << (Jt << BigInt(i2)) - Jt);
  nr.push(o2);
}
var [Fi, zi2] = Ri(nr, true);
var rr = (t, e, n2) => n2 > 32 ? Li(t, e, n2) : _i(t, e, n2);
var or = (t, e, n2) => n2 > 32 ? ji(t, e, n2) : $i(t, e, n2);
function Zi(t, e = 24) {
  const n2 = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let s = 0; s < 10; s++) n2[s] = t[s] ^ t[s + 10] ^ t[s + 20] ^ t[s + 30] ^ t[s + 40];
    for (let s = 0; s < 10; s += 2) {
      const c2 = (s + 8) % 10, a = (s + 2) % 10, u2 = n2[a], l3 = n2[a + 1], f2 = rr(u2, l3, 1) ^ n2[c2], h2 = or(u2, l3, 1) ^ n2[c2 + 1];
      for (let y3 = 0; y3 < 50; y3 += 10) t[s + y3] ^= f2, t[s + y3 + 1] ^= h2;
    }
    let o2 = t[2], i2 = t[3];
    for (let s = 0; s < 24; s++) {
      const c2 = er2[s], a = rr(o2, i2, c2), u2 = or(o2, i2, c2), l3 = tr2[s];
      o2 = t[l3], i2 = t[l3 + 1], t[l3] = a, t[l3 + 1] = u2;
    }
    for (let s = 0; s < 50; s += 10) {
      for (let c2 = 0; c2 < 10; c2++) n2[c2] = t[s + c2];
      for (let c2 = 0; c2 < 10; c2++) t[s + c2] ^= ~n2[(c2 + 2) % 10] & n2[(c2 + 4) % 10];
    }
    t[0] ^= Fi[r], t[1] ^= zi2[r];
  }
  n2.fill(0);
}
var En = class _En extends ke {
  constructor(e, n2, r, o2 = false, i2 = 24) {
    if (super(), this.blockLen = e, this.suffix = n2, this.outputLen = r, this.enableXOF = o2, this.rounds = i2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Wt(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Ci(this.state);
  }
  keccak() {
    Xn || Jn(this.state32), Zi(this.state32, this.rounds), Xn || Jn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Rt(this);
    const { blockLen: n2, state: r } = this;
    e = $t(e);
    const o2 = e.length;
    for (let i2 = 0; i2 < o2; ) {
      const s = Math.min(n2 - this.pos, o2 - i2);
      for (let c2 = 0; c2 < s; c2++) r[this.pos++] ^= e[i2++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n2, pos: r, blockLen: o2 } = this;
    e[r] ^= n2, (n2 & 128) !== 0 && r === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Rt(this, false), Xt(e), this.finish();
    const n2 = this.state, { blockLen: r } = this;
    for (let o2 = 0, i2 = e.length; o2 < i2; ) {
      this.posOut >= r && this.keccak();
      const s = Math.min(r - this.posOut, i2 - o2);
      e.set(n2.subarray(this.posOut, this.posOut + s), o2), this.posOut += s, o2 += s;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Wt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Gn(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n2, suffix: r, outputLen: o2, rounds: i2, enableXOF: s } = this;
    return e || (e = new _En(n2, r, o2, s, i2)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i2, e.suffix = r, e.outputLen = o2, e.enableXOF = s, e.destroyed = this.destroyed, e;
  }
};
var Yi = (t, e, n2) => Qn(() => new En(e, t, n2));
var Gi = Yi(1, 136, 256 / 8);
var Wi = "https://rpc.walletconnect.org/v1";
function Ve(t) {
  const e = `Ethereum Signed Message:
${t.length}`, n2 = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(Gi(n2)).toString("hex");
}
async function ir2(t, e, n2, r, o2, i2) {
  switch (n2.t) {
    case "eip191":
      return await sr2(t, e, n2.s);
    case "eip1271":
      return await cr(t, e, n2.s, r, o2, i2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n2.t}`);
  }
}
async function sr2(t, e, n2) {
  return (await recoverAddress({ hash: Ve(e), signature: n2 })).toLowerCase() === t.toLowerCase();
}
async function cr(t, e, n2, r, o2, i2) {
  const s = Ne(r);
  if (!s.namespace || !s.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);
  try {
    const c2 = "0x1626ba7e", a = "0000000000000000000000000000000000000000000000000000000000000040", u2 = "0000000000000000000000000000000000000000000000000000000000000041", l3 = n2.substring(2), f2 = Ve(e).substring(2), h2 = c2 + f2 + a + u2 + l3, y3 = await fetch(`${i2 || Wi}/?chainId=${r}&projectId=${o2}`, { method: "POST", body: JSON.stringify({ id: Xi(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: h2 }, "latest"] }) }), { result: E4 } = await y3.json();
    return E4 ? E4.slice(0, c2.length).toLowerCase() === c2.toLowerCase() : false;
  } catch (c2) {
    return console.error("isValidEip1271Signature: ", c2), false;
  }
}
function Xi() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Ji(t) {
  const e = atob(t), n2 = new Uint8Array(e.length);
  for (let s = 0; s < e.length; s++) n2[s] = e.charCodeAt(s);
  const r = n2[0];
  if (r === 0) throw new Error("No signatures found");
  const o2 = 1 + r * 64;
  if (n2.length < o2) throw new Error("Transaction data too short for claimed signature count");
  if (n2.length < 100) throw new Error("Transaction too short");
  const i2 = Buffer.from(t, "base64").slice(1, 65);
  return esm_default.encode(i2);
}
var Qi = Object.defineProperty;
var ts = Object.defineProperties;
var es = Object.getOwnPropertyDescriptors;
var ar = Object.getOwnPropertySymbols;
var ns = Object.prototype.hasOwnProperty;
var rs = Object.prototype.propertyIsEnumerable;
var ur = (t, e, n2) => e in t ? Qi(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var Me = (t, e) => {
  for (var n2 in e || (e = {})) ns.call(e, n2) && ur(t, n2, e[n2]);
  if (ar) for (var n2 of ar(e)) rs.call(e, n2) && ur(t, n2, e[n2]);
  return t;
};
var fr = (t, e) => ts(t, es(e));
var os = "did:pkh:";
var de = (t) => t?.split(":");
var lr = (t) => {
  const e = t && de(t);
  if (e) return t.includes(os) ? e[3] : e[1];
};
var dr = (t) => {
  const e = t && de(t);
  if (e) return e[2] + ":" + e[3];
};
var De = (t) => {
  const e = t && de(t);
  if (e) return e.pop();
};
async function is(t) {
  const { cacao: e, projectId: n2 } = t, { s: r, p: o2 } = e, i2 = hr(o2, o2.iss), s = De(o2.iss);
  return await ir2(s, i2, r, dr(o2.iss), n2);
}
var hr = (t, e) => {
  const n2 = `${t.domain} wants you to sign in with your Ethereum account:`, r = De(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o2 = t.statement || void 0;
  const i2 = `URI: ${t.aud || t.uri}`, s = `Version: ${t.version}`, c2 = `Chain ID: ${lr(e)}`, a = `Nonce: ${t.nonce}`, u2 = `Issued At: ${t.iat}`, l3 = t.exp ? `Expiration Time: ${t.exp}` : void 0, f2 = t.nbf ? `Not Before: ${t.nbf}` : void 0, h2 = t.requestId ? `Request ID: ${t.requestId}` : void 0, y3 = t.resources ? `Resources:${t.resources.map((p) => `
- ${p}`).join("")}` : void 0, E4 = pe(t.resources);
  if (E4) {
    const p = yt(E4);
    o2 = Ke(o2, p);
  }
  return [n2, r, "", o2, "", i2, s, c2, a, u2, l3, f2, h2, y3].filter((p) => p != null).join(`
`);
};
function mr(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function wr(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function at(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((n2) => {
    const r = t.att[n2];
    if (Array.isArray(r)) throw new Error(`Resource must be an object: ${n2}`);
    if (typeof r != "object") throw new Error(`Resource must be an object: ${n2}`);
    if (!Object.keys(r).length) throw new Error(`Resource object is empty: ${n2}`);
    Object.keys(r).forEach((o2) => {
      const i2 = r[o2];
      if (!Array.isArray(i2)) throw new Error(`Ability limits ${o2} must be an array of objects, found: ${i2}`);
      if (!i2.length) throw new Error(`Value of ${o2} is empty array, must be an array with objects`);
      i2.forEach((s) => {
        if (typeof s != "object") throw new Error(`Ability limits (${o2}) must be an array of objects, found: ${s}`);
      });
    });
  });
}
function br(t, e, n2, r = {}) {
  return n2?.sort((o2, i2) => o2.localeCompare(i2)), { att: { [t]: He(e, n2, r) } };
}
function He(t, e, n2 = {}) {
  e = e?.sort((o2, i2) => o2.localeCompare(i2));
  const r = e.map((o2) => ({ [`${t}/${o2}`]: [n2] }));
  return Object.assign({}, ...r);
}
function he(t) {
  return at(t), `urn:recap:${mr(t).replace(/=/g, "")}`;
}
function yt(t) {
  const e = wr(t.replace("urn:recap:", ""));
  return at(e), e;
}
function fs(t, e, n2) {
  const r = br(t, e, n2);
  return he(r);
}
function qe(t) {
  return t && t.includes("urn:recap:");
}
function ls(t, e) {
  const n2 = yt(t), r = yt(e), o2 = vr(n2, r);
  return he(o2);
}
function vr(t, e) {
  at(t), at(e);
  const n2 = Object.keys(t.att).concat(Object.keys(e.att)).sort((o2, i2) => o2.localeCompare(i2)), r = { att: {} };
  return n2.forEach((o2) => {
    var i2, s;
    Object.keys(((i2 = t.att) == null ? void 0 : i2[o2]) || {}).concat(Object.keys(((s = e.att) == null ? void 0 : s[o2]) || {})).sort((c2, a) => c2.localeCompare(a)).forEach((c2) => {
      var a, u2;
      r.att[o2] = fr(Me({}, r.att[o2]), { [c2]: ((a = t.att[o2]) == null ? void 0 : a[c2]) || ((u2 = e.att[o2]) == null ? void 0 : u2[c2]) });
    });
  }), r;
}
function Ke(t = "", e) {
  at(e);
  const n2 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n2)) return t;
  const r = [];
  let o2 = 0;
  Object.keys(e.att).forEach((c2) => {
    const a = Object.keys(e.att[c2]).map((f2) => ({ ability: f2.split("/")[0], action: f2.split("/")[1] }));
    a.sort((f2, h2) => f2.action.localeCompare(h2.action));
    const u2 = {};
    a.forEach((f2) => {
      u2[f2.ability] || (u2[f2.ability] = []), u2[f2.ability].push(f2.action);
    });
    const l3 = Object.keys(u2).map((f2) => (o2++, `(${o2}) '${f2}': '${u2[f2].join("', '")}' for '${c2}'.`));
    r.push(l3.join(", ").replace(".,", "."));
  });
  const i2 = r.join(" "), s = `${n2}${i2}`;
  return `${t ? t + " " : ""}${s}`;
}
function ds(t) {
  var e;
  const n2 = yt(t);
  at(n2);
  const r = (e = n2.att) == null ? void 0 : e.eip155;
  return r ? Object.keys(r).map((o2) => o2.split("/")[1]) : [];
}
function hs(t) {
  const e = yt(t);
  at(e);
  const n2 = [];
  return Object.values(e.att).forEach((r) => {
    Object.values(r).forEach((o2) => {
      var i2;
      (i2 = o2?.[0]) != null && i2.chains && n2.push(o2[0].chains);
    });
  }), [...new Set(n2.flat())];
}
function pe(t) {
  if (!t) return;
  const e = t?.[t.length - 1];
  return qe(e) ? e : void 0;
}
function Fe(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Sr(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function tt(t, ...e) {
  if (!Sr(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Or(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function ps(t, e) {
  tt(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function Ar(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
var mt = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
var gs = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
var ys = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ys) throw new Error("Non little-endian hardware is not supported");
function ms(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function ze(t) {
  if (typeof t == "string") t = ms(t);
  else if (Sr(t)) t = Ze(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function ws(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function bs(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r = 0; r < t.length; r++) n2 |= t[r] ^ e[r];
  return n2 === 0;
}
var Es = (t, e) => {
  function n2(r, ...o2) {
    if (tt(r), t.nonceLength !== void 0) {
      const l3 = o2[0];
      if (!l3) throw new Error("nonce / iv required");
      t.varSizeNonce ? tt(l3) : tt(l3, t.nonceLength);
    }
    const i2 = t.tagLength;
    i2 && o2[1] !== void 0 && tt(o2[1]);
    const s = e(r, ...o2), c2 = (l3, f2) => {
      if (f2 !== void 0) {
        if (l3 !== 2) throw new Error("cipher output not supported");
        tt(f2);
      }
    };
    let a = false;
    return { encrypt(l3, f2) {
      if (a) throw new Error("cannot encrypt() twice with same key + nonce");
      return a = true, tt(l3), c2(s.encrypt.length, f2), s.encrypt(l3, f2);
    }, decrypt(l3, f2) {
      if (tt(l3), i2 && l3.length < i2) throw new Error("invalid ciphertext length: smaller than tagLength=" + i2);
      return c2(s.decrypt.length, f2), s.decrypt(l3, f2);
    } };
  }
  return Object.assign(n2, t), n2;
};
function Br(t, e, n2 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n2 && !vs(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function Ir(t, e, n2, r) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r);
  const o2 = BigInt(32), i2 = BigInt(4294967295), s = Number(n2 >> o2 & i2), c2 = Number(n2 & i2), a = r ? 4 : 0, u2 = r ? 0 : 4;
  t.setUint32(e + a, s, r), t.setUint32(e + u2, c2, r);
}
function vs(t) {
  return t.byteOffset % 4 === 0;
}
function Ze(t) {
  return Uint8Array.from(t);
}
function jt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
var Nr = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var xs = Nr("expand 16-byte k");
var Ss = Nr("expand 32-byte k");
var Os = mt(xs);
var As = mt(Ss);
function V2(t, e) {
  return t << e | t >>> 32 - e;
}
function Ye(t) {
  return t.byteOffset % 4 === 0;
}
var ge = 64;
var Bs = 16;
var Ur = 2 ** 32 - 1;
var Tr = new Uint32Array();
function Is(t, e, n2, r, o2, i2, s, c2) {
  const a = o2.length, u2 = new Uint8Array(ge), l3 = mt(u2), f2 = Ye(o2) && Ye(i2), h2 = f2 ? mt(o2) : Tr, y3 = f2 ? mt(i2) : Tr;
  for (let E4 = 0; E4 < a; s++) {
    if (t(e, n2, r, l3, s, c2), s >= Ur) throw new Error("arx: counter overflow");
    const p = Math.min(ge, a - E4);
    if (f2 && p === ge) {
      const d2 = E4 / 4;
      if (E4 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let v2 = 0, m; v2 < Bs; v2++) m = d2 + v2, y3[m] = h2[m] ^ l3[v2];
      E4 += ge;
      continue;
    }
    for (let d2 = 0, v2; d2 < p; d2++) v2 = E4 + d2, i2[v2] = o2[v2] ^ u2[d2];
    E4 += p;
  }
}
function Ns(t, e) {
  const { allowShortKeys: n2, extendNonceFn: r, counterLength: o2, counterRight: i2, rounds: s } = ws({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return Fe(o2), Fe(s), Ar(i2), Ar(n2), (c2, a, u2, l3, f2 = 0) => {
    tt(c2), tt(a), tt(u2);
    const h2 = u2.length;
    if (l3 === void 0 && (l3 = new Uint8Array(h2)), tt(l3), Fe(f2), f2 < 0 || f2 >= Ur) throw new Error("arx: counter overflow");
    if (l3.length < h2) throw new Error(`arx: output (${l3.length}) is shorter than data (${h2})`);
    const y3 = [];
    let E4 = c2.length, p, d2;
    if (E4 === 32) y3.push(p = Ze(c2)), d2 = As;
    else if (E4 === 16 && n2) p = new Uint8Array(32), p.set(c2), p.set(c2, 16), d2 = Os, y3.push(p);
    else throw new Error(`arx: invalid 32-byte key, got length=${E4}`);
    Ye(a) || y3.push(a = Ze(a));
    const v2 = mt(p);
    if (r) {
      if (a.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r(d2, v2, mt(a.subarray(0, 16)), v2), a = a.subarray(16);
    }
    const m = 16 - o2;
    if (m !== a.length) throw new Error(`arx: nonce must be ${m} or 16 bytes`);
    if (m !== 12) {
      const N3 = new Uint8Array(12);
      N3.set(a, i2 ? 0 : 12 - a.length), a = N3, y3.push(a);
    }
    const O2 = mt(a);
    return Is(t, d2, v2, O2, u2, l3, f2, s), jt(...y3), l3;
  };
}
var F = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var Us = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = ze(e), tt(e, 32);
    const n2 = F(e, 0), r = F(e, 2), o2 = F(e, 4), i2 = F(e, 6), s = F(e, 8), c2 = F(e, 10), a = F(e, 12), u2 = F(e, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r << 3) & 8191, this.r[2] = (r >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | i2 << 9) & 8191, this.r[4] = (i2 >>> 4 | s << 12) & 255, this.r[5] = s >>> 1 & 8190, this.r[6] = (s >>> 14 | c2 << 2) & 8191, this.r[7] = (c2 >>> 11 | a << 5) & 8065, this.r[8] = (a >>> 8 | u2 << 8) & 8191, this.r[9] = u2 >>> 5 & 127;
    for (let l3 = 0; l3 < 8; l3++) this.pad[l3] = F(e, 16 + 2 * l3);
  }
  process(e, n2, r = false) {
    const o2 = r ? 0 : 2048, { h: i2, r: s } = this, c2 = s[0], a = s[1], u2 = s[2], l3 = s[3], f2 = s[4], h2 = s[5], y3 = s[6], E4 = s[7], p = s[8], d2 = s[9], v2 = F(e, n2 + 0), m = F(e, n2 + 2), O2 = F(e, n2 + 4), N3 = F(e, n2 + 6), $3 = F(e, n2 + 8), B2 = F(e, n2 + 10), A2 = F(e, n2 + 12), T2 = F(e, n2 + 14);
    let S2 = i2[0] + (v2 & 8191), L2 = i2[1] + ((v2 >>> 13 | m << 3) & 8191), U4 = i2[2] + ((m >>> 10 | O2 << 6) & 8191), _ = i2[3] + ((O2 >>> 7 | N3 << 9) & 8191), j2 = i2[4] + ((N3 >>> 4 | $3 << 12) & 8191), g = i2[5] + ($3 >>> 1 & 8191), w = i2[6] + (($3 >>> 14 | B2 << 2) & 8191), b3 = i2[7] + ((B2 >>> 11 | A2 << 5) & 8191), I2 = i2[8] + ((A2 >>> 8 | T2 << 8) & 8191), R2 = i2[9] + (T2 >>> 5 | o2), x2 = 0, C5 = x2 + S2 * c2 + L2 * (5 * d2) + U4 * (5 * p) + _ * (5 * E4) + j2 * (5 * y3);
    x2 = C5 >>> 13, C5 &= 8191, C5 += g * (5 * h2) + w * (5 * f2) + b3 * (5 * l3) + I2 * (5 * u2) + R2 * (5 * a), x2 += C5 >>> 13, C5 &= 8191;
    let P = x2 + S2 * a + L2 * c2 + U4 * (5 * d2) + _ * (5 * p) + j2 * (5 * E4);
    x2 = P >>> 13, P &= 8191, P += g * (5 * y3) + w * (5 * h2) + b3 * (5 * f2) + I2 * (5 * l3) + R2 * (5 * u2), x2 += P >>> 13, P &= 8191;
    let k4 = x2 + S2 * u2 + L2 * a + U4 * c2 + _ * (5 * d2) + j2 * (5 * p);
    x2 = k4 >>> 13, k4 &= 8191, k4 += g * (5 * E4) + w * (5 * y3) + b3 * (5 * h2) + I2 * (5 * f2) + R2 * (5 * l3), x2 += k4 >>> 13, k4 &= 8191;
    let M3 = x2 + S2 * l3 + L2 * u2 + U4 * a + _ * c2 + j2 * (5 * d2);
    x2 = M3 >>> 13, M3 &= 8191, M3 += g * (5 * p) + w * (5 * E4) + b3 * (5 * y3) + I2 * (5 * h2) + R2 * (5 * f2), x2 += M3 >>> 13, M3 &= 8191;
    let D2 = x2 + S2 * f2 + L2 * l3 + U4 * u2 + _ * a + j2 * c2;
    x2 = D2 >>> 13, D2 &= 8191, D2 += g * (5 * d2) + w * (5 * p) + b3 * (5 * E4) + I2 * (5 * y3) + R2 * (5 * h2), x2 += D2 >>> 13, D2 &= 8191;
    let z = x2 + S2 * h2 + L2 * f2 + U4 * l3 + _ * u2 + j2 * a;
    x2 = z >>> 13, z &= 8191, z += g * c2 + w * (5 * d2) + b3 * (5 * p) + I2 * (5 * E4) + R2 * (5 * y3), x2 += z >>> 13, z &= 8191;
    let Z = x2 + S2 * y3 + L2 * h2 + U4 * f2 + _ * l3 + j2 * u2;
    x2 = Z >>> 13, Z &= 8191, Z += g * a + w * c2 + b3 * (5 * d2) + I2 * (5 * p) + R2 * (5 * E4), x2 += Z >>> 13, Z &= 8191;
    let st2 = x2 + S2 * E4 + L2 * y3 + U4 * h2 + _ * f2 + j2 * l3;
    x2 = st2 >>> 13, st2 &= 8191, st2 += g * u2 + w * a + b3 * c2 + I2 * (5 * d2) + R2 * (5 * p), x2 += st2 >>> 13, st2 &= 8191;
    let W2 = x2 + S2 * p + L2 * E4 + U4 * y3 + _ * h2 + j2 * f2;
    x2 = W2 >>> 13, W2 &= 8191, W2 += g * l3 + w * u2 + b3 * a + I2 * c2 + R2 * (5 * d2), x2 += W2 >>> 13, W2 &= 8191;
    let J3 = x2 + S2 * d2 + L2 * p + U4 * E4 + _ * y3 + j2 * h2;
    x2 = J3 >>> 13, J3 &= 8191, J3 += g * f2 + w * l3 + b3 * u2 + I2 * a + R2 * c2, x2 += J3 >>> 13, J3 &= 8191, x2 = (x2 << 2) + x2 | 0, x2 = x2 + C5 | 0, C5 = x2 & 8191, x2 = x2 >>> 13, P += x2, i2[0] = C5, i2[1] = P, i2[2] = k4, i2[3] = M3, i2[4] = D2, i2[5] = z, i2[6] = Z, i2[7] = st2, i2[8] = W2, i2[9] = J3;
  }
  finalize() {
    const { h: e, pad: n2 } = this, r = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c2 = 2; c2 < 10; c2++) e[c2] += o2, o2 = e[c2] >>> 13, e[c2] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r[0] = e[0] + 5, o2 = r[0] >>> 13, r[0] &= 8191;
    for (let c2 = 1; c2 < 10; c2++) r[c2] = e[c2] + o2, o2 = r[c2] >>> 13, r[c2] &= 8191;
    r[9] -= 8192;
    let i2 = (o2 ^ 1) - 1;
    for (let c2 = 0; c2 < 10; c2++) r[c2] &= i2;
    i2 = ~i2;
    for (let c2 = 0; c2 < 10; c2++) e[c2] = e[c2] & i2 | r[c2];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let s = e[0] + n2[0];
    e[0] = s & 65535;
    for (let c2 = 1; c2 < 8; c2++) s = (e[c2] + n2[c2] | 0) + (s >>> 16) | 0, e[c2] = s & 65535;
    jt(r);
  }
  update(e) {
    Or(this);
    const { buffer: n2, blockLen: r } = this;
    e = ze(e);
    const o2 = e.length;
    for (let i2 = 0; i2 < o2; ) {
      const s = Math.min(r - this.pos, o2 - i2);
      if (s === r) {
        for (; r <= o2 - i2; i2 += r) this.process(e, i2);
        continue;
      }
      n2.set(e.subarray(i2, i2 + s), this.pos), this.pos += s, i2 += s, this.pos === r && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    jt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    Or(this), ps(e, this), this.finished = true;
    const { buffer: n2, h: r } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n2[o2++] = 1; o2 < 16; o2++) n2[o2] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let i2 = 0;
    for (let s = 0; s < 8; s++) e[i2++] = r[s] >>> 0, e[i2++] = r[s] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r = e.slice(0, n2);
    return this.destroy(), r;
  }
};
function Ts(t) {
  const e = (r, o2) => t(o2).update(ze(r)).digest(), n2 = t(new Uint8Array(32));
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r) => t(r), e;
}
var Rs = Ts((t) => new Us(t));
function _s(t, e, n2, r, o2, i2 = 20) {
  let s = t[0], c2 = t[1], a = t[2], u2 = t[3], l3 = e[0], f2 = e[1], h2 = e[2], y3 = e[3], E4 = e[4], p = e[5], d2 = e[6], v2 = e[7], m = o2, O2 = n2[0], N3 = n2[1], $3 = n2[2], B2 = s, A2 = c2, T2 = a, S2 = u2, L2 = l3, U4 = f2, _ = h2, j2 = y3, g = E4, w = p, b3 = d2, I2 = v2, R2 = m, x2 = O2, C5 = N3, P = $3;
  for (let M3 = 0; M3 < i2; M3 += 2) B2 = B2 + L2 | 0, R2 = V2(R2 ^ B2, 16), g = g + R2 | 0, L2 = V2(L2 ^ g, 12), B2 = B2 + L2 | 0, R2 = V2(R2 ^ B2, 8), g = g + R2 | 0, L2 = V2(L2 ^ g, 7), A2 = A2 + U4 | 0, x2 = V2(x2 ^ A2, 16), w = w + x2 | 0, U4 = V2(U4 ^ w, 12), A2 = A2 + U4 | 0, x2 = V2(x2 ^ A2, 8), w = w + x2 | 0, U4 = V2(U4 ^ w, 7), T2 = T2 + _ | 0, C5 = V2(C5 ^ T2, 16), b3 = b3 + C5 | 0, _ = V2(_ ^ b3, 12), T2 = T2 + _ | 0, C5 = V2(C5 ^ T2, 8), b3 = b3 + C5 | 0, _ = V2(_ ^ b3, 7), S2 = S2 + j2 | 0, P = V2(P ^ S2, 16), I2 = I2 + P | 0, j2 = V2(j2 ^ I2, 12), S2 = S2 + j2 | 0, P = V2(P ^ S2, 8), I2 = I2 + P | 0, j2 = V2(j2 ^ I2, 7), B2 = B2 + U4 | 0, P = V2(P ^ B2, 16), b3 = b3 + P | 0, U4 = V2(U4 ^ b3, 12), B2 = B2 + U4 | 0, P = V2(P ^ B2, 8), b3 = b3 + P | 0, U4 = V2(U4 ^ b3, 7), A2 = A2 + _ | 0, R2 = V2(R2 ^ A2, 16), I2 = I2 + R2 | 0, _ = V2(_ ^ I2, 12), A2 = A2 + _ | 0, R2 = V2(R2 ^ A2, 8), I2 = I2 + R2 | 0, _ = V2(_ ^ I2, 7), T2 = T2 + j2 | 0, x2 = V2(x2 ^ T2, 16), g = g + x2 | 0, j2 = V2(j2 ^ g, 12), T2 = T2 + j2 | 0, x2 = V2(x2 ^ T2, 8), g = g + x2 | 0, j2 = V2(j2 ^ g, 7), S2 = S2 + L2 | 0, C5 = V2(C5 ^ S2, 16), w = w + C5 | 0, L2 = V2(L2 ^ w, 12), S2 = S2 + L2 | 0, C5 = V2(C5 ^ S2, 8), w = w + C5 | 0, L2 = V2(L2 ^ w, 7);
  let k4 = 0;
  r[k4++] = s + B2 | 0, r[k4++] = c2 + A2 | 0, r[k4++] = a + T2 | 0, r[k4++] = u2 + S2 | 0, r[k4++] = l3 + L2 | 0, r[k4++] = f2 + U4 | 0, r[k4++] = h2 + _ | 0, r[k4++] = y3 + j2 | 0, r[k4++] = E4 + g | 0, r[k4++] = p + w | 0, r[k4++] = d2 + b3 | 0, r[k4++] = v2 + I2 | 0, r[k4++] = m + R2 | 0, r[k4++] = O2 + x2 | 0, r[k4++] = N3 + C5 | 0, r[k4++] = $3 + P | 0;
}
var $s = Ns(_s, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Ls = new Uint8Array(16);
var Rr = (t, e) => {
  t.update(e);
  const n2 = e.length % 16;
  n2 && t.update(Ls.subarray(n2));
};
var js = new Uint8Array(32);
function _r(t, e, n2, r, o2) {
  const i2 = t(e, n2, js), s = Rs.create(i2);
  o2 && Rr(s, o2), Rr(s, r);
  const c2 = new Uint8Array(16), a = gs(c2);
  Ir(a, 0, BigInt(o2 ? o2.length : 0), true), Ir(a, 8, BigInt(r.length), true), s.update(c2);
  const u2 = s.digest();
  return jt(i2, c2), u2;
}
var Cs = (t) => (e, n2, r) => ({ encrypt(i2, s) {
  const c2 = i2.length;
  s = Br(c2 + 16, s, false), s.set(i2);
  const a = s.subarray(0, -16);
  t(e, n2, a, a, 1);
  const u2 = _r(t, e, n2, a, r);
  return s.set(u2, c2), jt(u2), s;
}, decrypt(i2, s) {
  s = Br(i2.length - 16, s, false);
  const c2 = i2.subarray(0, -16), a = i2.subarray(-16), u2 = _r(t, e, n2, c2, r);
  if (!bs(a, u2)) throw new Error("invalid tag");
  return s.set(i2.subarray(0, -16)), t(e, n2, s, s, 1), jt(u2), s;
} });
var $r = Es({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Cs($s));
var Lr = class extends ke {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, Ce(e);
    const r = $t(n2);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, i2 = new Uint8Array(o2);
    i2.set(r.length > o2 ? e.create().update(r).digest() : r);
    for (let s = 0; s < i2.length; s++) i2[s] ^= 54;
    this.iHash.update(i2), this.oHash = e.create();
    for (let s = 0; s < i2.length; s++) i2[s] ^= 106;
    this.oHash.update(i2), i2.fill(0);
  }
  update(e) {
    return Rt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Rt(this), Xt(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r, finished: o2, destroyed: i2, blockLen: s, outputLen: c2 } = this;
    return e = e, e.finished = o2, e.destroyed = i2, e.blockLen = s, e.outputLen = c2, e.oHash = n2._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ye = (t, e, n2) => new Lr(t, e).update(n2).digest();
ye.create = (t, e) => new Lr(t, e);
var Ge = new Uint8Array([0]);
var jr = new Uint8Array();
function Ms(t, e, n2, r) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r);
  const o2 = BigInt(32), i2 = BigInt(4294967295), s = Number(n2 >> o2 & i2), c2 = Number(n2 & i2), a = r ? 4 : 0, u2 = r ? 0 : 4;
  t.setUint32(e + a, s, r), t.setUint32(e + u2, c2, r);
}
function Ds(t, e, n2) {
  return t & e ^ ~t & n2;
}
function Hs(t, e, n2) {
  return t & e ^ t & n2 ^ e & n2;
}
var qs = class extends ke {
  constructor(e, n2, r, o2) {
    super(), this.blockLen = e, this.outputLen = n2, this.padOffset = r, this.isLE = o2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Pe(this.buffer);
  }
  update(e) {
    Rt(this);
    const { view: n2, buffer: r, blockLen: o2 } = this;
    e = $t(e);
    const i2 = e.length;
    for (let s = 0; s < i2; ) {
      const c2 = Math.min(o2 - this.pos, i2 - s);
      if (c2 === o2) {
        const a = Pe(e);
        for (; o2 <= i2 - s; s += o2) this.process(a, s);
        continue;
      }
      r.set(e.subarray(s, s + c2), this.pos), this.pos += c2, s += c2, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Rt(this), Gn(e, this), this.finished = true;
    const { buffer: n2, view: r, blockLen: o2, isLE: i2 } = this;
    let { pos: s } = this;
    n2[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o2 - s && (this.process(r, 0), s = 0);
    for (let f2 = s; f2 < o2; f2++) n2[f2] = 0;
    Ms(r, o2 - 8, BigInt(this.length * 8), i2), this.process(r, 0);
    const c2 = Pe(e), a = this.outputLen;
    if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u2 = a / 4, l3 = this.get();
    if (u2 > l3.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f2 = 0; f2 < u2; f2++) c2.setUint32(4 * f2, l3[f2], i2);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r = e.slice(0, n2);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r, length: o2, finished: i2, destroyed: s, pos: c2 } = this;
    return e.length = o2, e.pos = c2, e.finished = i2, e.destroyed = s, o2 % n2 && e.buffer.set(r), e;
  }
};
var Ks = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var wt = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var bt = new Uint32Array(64);
var Fs = class extends qs {
  constructor() {
    super(64, 32, 8, false), this.A = wt[0] | 0, this.B = wt[1] | 0, this.C = wt[2] | 0, this.D = wt[3] | 0, this.E = wt[4] | 0, this.F = wt[5] | 0, this.G = wt[6] | 0, this.H = wt[7] | 0;
  }
  get() {
    const { A: e, B: n2, C: r, D: o2, E: i2, F: s, G: c2, H: a } = this;
    return [e, n2, r, o2, i2, s, c2, a];
  }
  set(e, n2, r, o2, i2, s, c2, a) {
    this.A = e | 0, this.B = n2 | 0, this.C = r | 0, this.D = o2 | 0, this.E = i2 | 0, this.F = s | 0, this.G = c2 | 0, this.H = a | 0;
  }
  process(e, n2) {
    for (let f2 = 0; f2 < 16; f2++, n2 += 4) bt[f2] = e.getUint32(n2, false);
    for (let f2 = 16; f2 < 64; f2++) {
      const h2 = bt[f2 - 15], y3 = bt[f2 - 2], E4 = ct(h2, 7) ^ ct(h2, 18) ^ h2 >>> 3, p = ct(y3, 17) ^ ct(y3, 19) ^ y3 >>> 10;
      bt[f2] = p + bt[f2 - 7] + E4 + bt[f2 - 16] | 0;
    }
    let { A: r, B: o2, C: i2, D: s, E: c2, F: a, G: u2, H: l3 } = this;
    for (let f2 = 0; f2 < 64; f2++) {
      const h2 = ct(c2, 6) ^ ct(c2, 11) ^ ct(c2, 25), y3 = l3 + h2 + Ds(c2, a, u2) + Ks[f2] + bt[f2] | 0, p = (ct(r, 2) ^ ct(r, 13) ^ ct(r, 22)) + Hs(r, o2, i2) | 0;
      l3 = u2, u2 = a, a = c2, c2 = s + y3 | 0, s = i2, i2 = o2, o2 = r, r = y3 + p | 0;
    }
    r = r + this.A | 0, o2 = o2 + this.B | 0, i2 = i2 + this.C | 0, s = s + this.D | 0, c2 = c2 + this.E | 0, a = a + this.F | 0, u2 = u2 + this.G | 0, l3 = l3 + this.H | 0, this.set(r, o2, i2, s, c2, a, u2, l3);
  }
  roundClean() {
    bt.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Qt = Qn(() => new Fs());
var me = BigInt(0);
var we = BigInt(1);
var zs = BigInt(2);
function St(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function te(t) {
  if (!St(t)) throw new Error("Uint8Array expected");
}
function Ct(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
var Zs = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Pt(t) {
  te(t);
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Zs[t[n2]];
  return e;
}
function kt(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function We(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? me : BigInt("0x" + t);
}
var ut = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Cr(t) {
  if (t >= ut._0 && t <= ut._9) return t - ut._0;
  if (t >= ut.A && t <= ut.F) return t - (ut.A - 10);
  if (t >= ut.a && t <= ut.f) return t - (ut.a - 10);
}
function Vt(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n2);
  for (let o2 = 0, i2 = 0; o2 < n2; o2++, i2 += 2) {
    const s = Cr(t.charCodeAt(i2)), c2 = Cr(t.charCodeAt(i2 + 1));
    if (s === void 0 || c2 === void 0) {
      const a = t[i2] + t[i2 + 1];
      throw new Error('hex string expected, got non-hex character "' + a + '" at index ' + i2);
    }
    r[o2] = s * 16 + c2;
  }
  return r;
}
function Ot(t) {
  return We(Pt(t));
}
function ee(t) {
  return te(t), We(Pt(Uint8Array.from(t).reverse()));
}
function Mt(t, e) {
  return Vt(t.toString(16).padStart(e * 2, "0"));
}
function be(t, e) {
  return Mt(t, e).reverse();
}
function Ys(t) {
  return Vt(kt(t));
}
function et(t, e, n2) {
  let r;
  if (typeof e == "string") try {
    r = Vt(e);
  } catch (i2) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + i2);
  }
  else if (St(e)) r = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o2);
  return r;
}
function ne(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const o2 = t[r];
    te(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r = 0, o2 = 0; r < t.length; r++) {
    const i2 = t[r];
    n2.set(i2, o2), o2 += i2.length;
  }
  return n2;
}
function Gs(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r = 0; r < t.length; r++) n2 |= t[r] ^ e[r];
  return n2 === 0;
}
function Ws(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
var Xe = (t) => typeof t == "bigint" && me <= t;
function Ee(t, e, n2) {
  return Xe(t) && Xe(e) && Xe(n2) && e <= t && t < n2;
}
function ft(t, e, n2, r) {
  if (!Ee(e, n2, r)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r + ", got " + e);
}
function Pr(t) {
  let e;
  for (e = 0; t > me; t >>= we, e += 1) ;
  return e;
}
function Xs(t, e) {
  return t >> BigInt(e) & we;
}
function Js(t, e, n2) {
  return t | (n2 ? we : me) << BigInt(e);
}
var Je = (t) => (zs << BigInt(t - 1)) - we;
var Qe = (t) => new Uint8Array(t);
var kr = (t) => Uint8Array.from(t);
function Vr(t, e, n2) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n2 != "function") throw new Error("hmacFn must be a function");
  let r = Qe(t), o2 = Qe(t), i2 = 0;
  const s = () => {
    r.fill(1), o2.fill(0), i2 = 0;
  }, c2 = (...f2) => n2(o2, r, ...f2), a = (f2 = Qe()) => {
    o2 = c2(kr([0]), f2), r = c2(), f2.length !== 0 && (o2 = c2(kr([1]), f2), r = c2());
  }, u2 = () => {
    if (i2++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let f2 = 0;
    const h2 = [];
    for (; f2 < e; ) {
      r = c2();
      const y3 = r.slice();
      h2.push(y3), f2 += r.length;
    }
    return ne(...h2);
  };
  return (f2, h2) => {
    s(), a(f2);
    let y3;
    for (; !(y3 = h2(u2())); ) a();
    return s(), y3;
  };
}
var Qs = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || St(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Dt(t, e, n2 = {}) {
  const r = (o2, i2, s) => {
    const c2 = Qs[i2];
    if (typeof c2 != "function") throw new Error("invalid validator function");
    const a = t[o2];
    if (!(s && a === void 0) && !c2(a, t)) throw new Error("param " + String(o2) + " is invalid. Expected " + i2 + ", got " + a);
  };
  for (const [o2, i2] of Object.entries(e)) r(o2, i2, false);
  for (const [o2, i2] of Object.entries(n2)) r(o2, i2, true);
  return t;
}
var tc = () => {
  throw new Error("not implemented");
};
function tn(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r) => {
    const o2 = e.get(n2);
    if (o2 !== void 0) return o2;
    const i2 = t(n2, ...r);
    return e.set(n2, i2), i2;
  };
}
var ec = Object.freeze({ __proto__: null, isBytes: St, abytes: te, abool: Ct, bytesToHex: Pt, numberToHexUnpadded: kt, hexToNumber: We, hexToBytes: Vt, bytesToNumberBE: Ot, bytesToNumberLE: ee, numberToBytesBE: Mt, numberToBytesLE: be, numberToVarBytesBE: Ys, ensureBytes: et, concatBytes: ne, equalBytes: Gs, utf8ToBytes: Ws, inRange: Ee, aInRange: ft, bitLen: Pr, bitGet: Xs, bitSet: Js, bitMask: Je, createHmacDrbg: Vr, validateObject: Dt, notImplemented: tc, memoized: tn });
var q = BigInt(0);
var H = BigInt(1);
var At = BigInt(2);
var nc = BigInt(3);
var en = BigInt(4);
var Mr = BigInt(5);
var Dr = BigInt(8);
function X(t, e) {
  const n2 = t % e;
  return n2 >= q ? n2 : e + n2;
}
function Hr(t, e, n2) {
  if (e < q) throw new Error("invalid exponent, negatives unsupported");
  if (n2 <= q) throw new Error("invalid modulus");
  if (n2 === H) return q;
  let r = H;
  for (; e > q; ) e & H && (r = r * t % n2), t = t * t % n2, e >>= H;
  return r;
}
function it(t, e, n2) {
  let r = t;
  for (; e-- > q; ) r *= r, r %= n2;
  return r;
}
function nn(t, e) {
  if (t === q) throw new Error("invert: expected non-zero number");
  if (e <= q) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = X(t, e), r = e, o2 = q, i2 = H;
  for (; n2 !== q; ) {
    const c2 = r / n2, a = r % n2, u2 = o2 - i2 * c2;
    r = n2, n2 = a, o2 = i2, i2 = u2;
  }
  if (r !== H) throw new Error("invert: does not exist");
  return X(o2, e);
}
function rc(t) {
  const e = (t - H) / At;
  let n2, r, o2;
  for (n2 = t - H, r = 0; n2 % At === q; n2 /= At, r++) ;
  for (o2 = At; o2 < t && Hr(o2, e, t) !== t - H; o2++) if (o2 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r === 1) {
    const s = (t + H) / en;
    return function(a, u2) {
      const l3 = a.pow(u2, s);
      if (!a.eql(a.sqr(l3), u2)) throw new Error("Cannot find square root");
      return l3;
    };
  }
  const i2 = (n2 + H) / At;
  return function(c2, a) {
    if (c2.pow(a, e) === c2.neg(c2.ONE)) throw new Error("Cannot find square root");
    let u2 = r, l3 = c2.pow(c2.mul(c2.ONE, o2), n2), f2 = c2.pow(a, i2), h2 = c2.pow(a, n2);
    for (; !c2.eql(h2, c2.ONE); ) {
      if (c2.eql(h2, c2.ZERO)) return c2.ZERO;
      let y3 = 1;
      for (let p = c2.sqr(h2); y3 < u2 && !c2.eql(p, c2.ONE); y3++) p = c2.sqr(p);
      const E4 = c2.pow(l3, H << BigInt(u2 - y3 - 1));
      l3 = c2.sqr(E4), f2 = c2.mul(f2, E4), h2 = c2.mul(h2, l3), u2 = y3;
    }
    return f2;
  };
}
function oc(t) {
  if (t % en === nc) {
    const e = (t + H) / en;
    return function(r, o2) {
      const i2 = r.pow(o2, e);
      if (!r.eql(r.sqr(i2), o2)) throw new Error("Cannot find square root");
      return i2;
    };
  }
  if (t % Dr === Mr) {
    const e = (t - Mr) / Dr;
    return function(r, o2) {
      const i2 = r.mul(o2, At), s = r.pow(i2, e), c2 = r.mul(o2, s), a = r.mul(r.mul(c2, At), s), u2 = r.mul(c2, r.sub(a, r.ONE));
      if (!r.eql(r.sqr(u2), o2)) throw new Error("Cannot find square root");
      return u2;
    };
  }
  return rc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function sc(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n2 = ic.reduce((r, o2) => (r[o2] = "function", r), e);
  return Dt(t, n2);
}
function cc(t, e, n2) {
  if (n2 < q) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === q) return t.ONE;
  if (n2 === H) return e;
  let r = t.ONE, o2 = e;
  for (; n2 > q; ) n2 & H && (r = t.mul(r, o2)), o2 = t.sqr(o2), n2 >>= H;
  return r;
}
function ac(t, e) {
  const n2 = new Array(e.length), r = e.reduce((i2, s, c2) => t.is0(s) ? i2 : (n2[c2] = i2, t.mul(i2, s)), t.ONE), o2 = t.inv(r);
  return e.reduceRight((i2, s, c2) => t.is0(s) ? i2 : (n2[c2] = t.mul(i2, n2[c2]), t.mul(i2, s)), o2), n2;
}
function qr(t, e) {
  const n2 = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r };
}
function Kr(t, e, n2 = false, r = {}) {
  if (t <= q) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o2, nByteLength: i2 } = qr(t, e);
  if (i2 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let s;
  const c2 = Object.freeze({ ORDER: t, isLE: n2, BITS: o2, BYTES: i2, MASK: Je(o2), ZERO: q, ONE: H, create: (a) => X(a, t), isValid: (a) => {
    if (typeof a != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof a);
    return q <= a && a < t;
  }, is0: (a) => a === q, isOdd: (a) => (a & H) === H, neg: (a) => X(-a, t), eql: (a, u2) => a === u2, sqr: (a) => X(a * a, t), add: (a, u2) => X(a + u2, t), sub: (a, u2) => X(a - u2, t), mul: (a, u2) => X(a * u2, t), pow: (a, u2) => cc(c2, a, u2), div: (a, u2) => X(a * nn(u2, t), t), sqrN: (a) => a * a, addN: (a, u2) => a + u2, subN: (a, u2) => a - u2, mulN: (a, u2) => a * u2, inv: (a) => nn(a, t), sqrt: r.sqrt || ((a) => (s || (s = oc(t)), s(c2, a))), invertBatch: (a) => ac(c2, a), cmov: (a, u2, l3) => l3 ? u2 : a, toBytes: (a) => n2 ? be(a, i2) : Mt(a, i2), fromBytes: (a) => {
    if (a.length !== i2) throw new Error("Field.fromBytes: expected " + i2 + " bytes, got " + a.length);
    return n2 ? ee(a) : Ot(a);
  } });
  return Object.freeze(c2);
}
function Fr(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function zr(t) {
  const e = Fr(t);
  return e + Math.ceil(e / 2);
}
function uc(t, e, n2 = false) {
  const r = t.length, o2 = Fr(e), i2 = zr(e);
  if (r < 16 || r < i2 || r > 1024) throw new Error("expected " + i2 + "-1024 bytes of input, got " + r);
  const s = n2 ? ee(t) : Ot(t), c2 = X(s, e - H) + H;
  return n2 ? be(c2, o2) : Mt(c2, o2);
}
var Zr = BigInt(0);
var ve = BigInt(1);
function rn(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function Yr(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function on(t, e) {
  Yr(t, e);
  const n2 = Math.ceil(e / t) + 1, r = 2 ** (t - 1);
  return { windows: n2, windowSize: r };
}
function fc(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r);
  });
}
function lc(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r);
  });
}
var sn2 = /* @__PURE__ */ new WeakMap();
var Gr = /* @__PURE__ */ new WeakMap();
function cn(t) {
  return Gr.get(t) || 1;
}
function dc(t, e) {
  return { constTimeNegate: rn, hasPrecomputes(n2) {
    return cn(n2) !== 1;
  }, unsafeLadder(n2, r, o2 = t.ZERO) {
    let i2 = n2;
    for (; r > Zr; ) r & ve && (o2 = o2.add(i2)), i2 = i2.double(), r >>= ve;
    return o2;
  }, precomputeWindow(n2, r) {
    const { windows: o2, windowSize: i2 } = on(r, e), s = [];
    let c2 = n2, a = c2;
    for (let u2 = 0; u2 < o2; u2++) {
      a = c2, s.push(a);
      for (let l3 = 1; l3 < i2; l3++) a = a.add(c2), s.push(a);
      c2 = a.double();
    }
    return s;
  }, wNAF(n2, r, o2) {
    const { windows: i2, windowSize: s } = on(n2, e);
    let c2 = t.ZERO, a = t.BASE;
    const u2 = BigInt(2 ** n2 - 1), l3 = 2 ** n2, f2 = BigInt(n2);
    for (let h2 = 0; h2 < i2; h2++) {
      const y3 = h2 * s;
      let E4 = Number(o2 & u2);
      o2 >>= f2, E4 > s && (E4 -= l3, o2 += ve);
      const p = y3, d2 = y3 + Math.abs(E4) - 1, v2 = h2 % 2 !== 0, m = E4 < 0;
      E4 === 0 ? a = a.add(rn(v2, r[p])) : c2 = c2.add(rn(m, r[d2]));
    }
    return { p: c2, f: a };
  }, wNAFUnsafe(n2, r, o2, i2 = t.ZERO) {
    const { windows: s, windowSize: c2 } = on(n2, e), a = BigInt(2 ** n2 - 1), u2 = 2 ** n2, l3 = BigInt(n2);
    for (let f2 = 0; f2 < s; f2++) {
      const h2 = f2 * c2;
      if (o2 === Zr) break;
      let y3 = Number(o2 & a);
      if (o2 >>= l3, y3 > c2 && (y3 -= u2, o2 += ve), y3 === 0) continue;
      let E4 = r[h2 + Math.abs(y3) - 1];
      y3 < 0 && (E4 = E4.negate()), i2 = i2.add(E4);
    }
    return i2;
  }, getPrecomputes(n2, r, o2) {
    let i2 = sn2.get(r);
    return i2 || (i2 = this.precomputeWindow(r, n2), n2 !== 1 && sn2.set(r, o2(i2))), i2;
  }, wNAFCached(n2, r, o2) {
    const i2 = cn(n2);
    return this.wNAF(i2, this.getPrecomputes(i2, n2, o2), r);
  }, wNAFCachedUnsafe(n2, r, o2, i2) {
    const s = cn(n2);
    return s === 1 ? this.unsafeLadder(n2, r, i2) : this.wNAFUnsafe(s, this.getPrecomputes(s, n2, o2), r, i2);
  }, setWindowSize(n2, r) {
    Yr(r, e), Gr.set(n2, r), sn2.delete(n2);
  } };
}
function hc(t, e, n2, r) {
  if (fc(n2, t), lc(r, e), n2.length !== r.length) throw new Error("arrays of points and scalars must have equal length");
  const o2 = t.ZERO, i2 = Pr(BigInt(n2.length)), s = i2 > 12 ? i2 - 3 : i2 > 4 ? i2 - 2 : i2 ? 2 : 1, c2 = (1 << s) - 1, a = new Array(c2 + 1).fill(o2), u2 = Math.floor((e.BITS - 1) / s) * s;
  let l3 = o2;
  for (let f2 = u2; f2 >= 0; f2 -= s) {
    a.fill(o2);
    for (let y3 = 0; y3 < r.length; y3++) {
      const E4 = r[y3], p = Number(E4 >> BigInt(f2) & BigInt(c2));
      a[p] = a[p].add(n2[y3]);
    }
    let h2 = o2;
    for (let y3 = a.length - 1, E4 = o2; y3 > 0; y3--) E4 = E4.add(a[y3]), h2 = h2.add(E4);
    if (l3 = l3.add(h2), f2 !== 0) for (let y3 = 0; y3 < s; y3++) l3 = l3.double();
  }
  return l3;
}
function Wr(t) {
  return sc(t.Fp), Dt(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...qr(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var Ht = BigInt(0);
var an = BigInt(1);
function pc(t) {
  return Dt(t, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...t });
}
function gc(t) {
  const e = pc(t), { P: n2 } = e, r = (m) => X(m, n2), o2 = e.montgomeryBits, i2 = Math.ceil(o2 / 8), s = e.nByteLength, c2 = e.adjustScalarBytes || ((m) => m), a = e.powPminus2 || ((m) => Hr(m, n2 - BigInt(2), n2));
  function u2(m, O2, N3) {
    const $3 = r(m * (O2 - N3));
    return O2 = r(O2 - $3), N3 = r(N3 + $3), [O2, N3];
  }
  const l3 = (e.a - BigInt(2)) / BigInt(4);
  function f2(m, O2) {
    ft("u", m, Ht, n2), ft("scalar", O2, Ht, n2);
    const N3 = O2, $3 = m;
    let B2 = an, A2 = Ht, T2 = m, S2 = an, L2 = Ht, U4;
    for (let j2 = BigInt(o2 - 1); j2 >= Ht; j2--) {
      const g = N3 >> j2 & an;
      L2 ^= g, U4 = u2(L2, B2, T2), B2 = U4[0], T2 = U4[1], U4 = u2(L2, A2, S2), A2 = U4[0], S2 = U4[1], L2 = g;
      const w = B2 + A2, b3 = r(w * w), I2 = B2 - A2, R2 = r(I2 * I2), x2 = b3 - R2, C5 = T2 + S2, P = T2 - S2, k4 = r(P * w), M3 = r(C5 * I2), D2 = k4 + M3, z = k4 - M3;
      T2 = r(D2 * D2), S2 = r($3 * r(z * z)), B2 = r(b3 * R2), A2 = r(x2 * (b3 + r(l3 * x2)));
    }
    U4 = u2(L2, B2, T2), B2 = U4[0], T2 = U4[1], U4 = u2(L2, A2, S2), A2 = U4[0], S2 = U4[1];
    const _ = a(A2);
    return r(B2 * _);
  }
  function h2(m) {
    return be(r(m), i2);
  }
  function y3(m) {
    const O2 = et("u coordinate", m, i2);
    return s === 32 && (O2[31] &= 127), ee(O2);
  }
  function E4(m) {
    const O2 = et("scalar", m), N3 = O2.length;
    if (N3 !== i2 && N3 !== s) {
      let $3 = "" + i2 + " or " + s;
      throw new Error("invalid scalar, expected " + $3 + " bytes, got " + N3);
    }
    return ee(c2(O2));
  }
  function p(m, O2) {
    const N3 = y3(O2), $3 = E4(m), B2 = f2(N3, $3);
    if (B2 === Ht) throw new Error("invalid private or public key received");
    return h2(B2);
  }
  const d2 = h2(e.Gu);
  function v2(m) {
    return p(m, d2);
  }
  return { scalarMult: p, scalarMultBase: v2, getSharedSecret: (m, O2) => p(m, O2), getPublicKey: (m) => v2(m), utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) }, GuBytes: d2 };
}
var un = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var yc = BigInt(1);
var Xr = BigInt(2);
var mc = BigInt(3);
var wc = BigInt(5);
BigInt(8);
function bc(t) {
  const e = BigInt(10), n2 = BigInt(20), r = BigInt(40), o2 = BigInt(80), i2 = un, c2 = t * t % i2 * t % i2, a = it(c2, Xr, i2) * c2 % i2, u2 = it(a, yc, i2) * t % i2, l3 = it(u2, wc, i2) * u2 % i2, f2 = it(l3, e, i2) * l3 % i2, h2 = it(f2, n2, i2) * f2 % i2, y3 = it(h2, r, i2) * h2 % i2, E4 = it(y3, o2, i2) * y3 % i2, p = it(E4, o2, i2) * y3 % i2, d2 = it(p, e, i2) * l3 % i2;
  return { pow_p_5_8: it(d2, Xr, i2) * t % i2, b2: c2 };
}
function Ec(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var fn = gc({ P: un, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (t) => {
  const e = un, { pow_p_5_8: n2, b2: r } = bc(t);
  return X(it(n2, mc, e) * r, e);
}, adjustScalarBytes: Ec, randomBytes: Lt });
function Jr(t) {
  t.lowS !== void 0 && Ct("lowS", t.lowS), t.prehash !== void 0 && Ct("prehash", t.prehash);
}
function vc(t) {
  const e = Wr(t);
  Dt(e, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: n2, Fp: r, a: o2 } = e;
  if (n2) {
    if (!r.eql(o2, r.ZERO)) throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof n2 != "object" || typeof n2.beta != "bigint" || typeof n2.splitScalar != "function") throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
var { bytesToNumberBE: xc, hexToBytes: Sc } = ec;
var Oc = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var lt = { Err: Oc, _tlv: { encode: (t, e) => {
  const { Err: n2 } = lt;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length & 1) throw new n2("tlv.encode: unpadded data");
  const r = e.length / 2, o2 = kt(r);
  if (o2.length / 2 & 128) throw new n2("tlv.encode: long form length too big");
  const i2 = r > 127 ? kt(o2.length / 2 | 128) : "";
  return kt(t) + i2 + o2 + e;
}, decode(t, e) {
  const { Err: n2 } = lt;
  let r = 0;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length < 2 || e[r++] !== t) throw new n2("tlv.decode: wrong tlv");
  const o2 = e[r++], i2 = !!(o2 & 128);
  let s = 0;
  if (!i2) s = o2;
  else {
    const a = o2 & 127;
    if (!a) throw new n2("tlv.decode(long): indefinite length not supported");
    if (a > 4) throw new n2("tlv.decode(long): byte length is too big");
    const u2 = e.subarray(r, r + a);
    if (u2.length !== a) throw new n2("tlv.decode: length bytes not complete");
    if (u2[0] === 0) throw new n2("tlv.decode(long): zero leftmost byte");
    for (const l3 of u2) s = s << 8 | l3;
    if (r += a, s < 128) throw new n2("tlv.decode(long): not minimal encoding");
  }
  const c2 = e.subarray(r, r + s);
  if (c2.length !== s) throw new n2("tlv.decode: wrong value length");
  return { v: c2, l: e.subarray(r + s) };
} }, _int: { encode(t) {
  const { Err: e } = lt;
  if (t < dt) throw new e("integer: negative integers are not allowed");
  let n2 = kt(t);
  if (Number.parseInt(n2[0], 16) & 8 && (n2 = "00" + n2), n2.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n2;
}, decode(t) {
  const { Err: e } = lt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return xc(t);
} }, toSig(t) {
  const { Err: e, _int: n2, _tlv: r } = lt, o2 = typeof t == "string" ? Sc(t) : t;
  te(o2);
  const { v: i2, l: s } = r.decode(48, o2);
  if (s.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c2, l: a } = r.decode(2, i2), { v: u2, l: l3 } = r.decode(2, a);
  if (l3.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n2.decode(c2), s: n2.decode(u2) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n2 } = lt, r = e.encode(2, n2.encode(t.r)), o2 = e.encode(2, n2.encode(t.s)), i2 = r + o2;
  return e.encode(48, i2);
} };
var dt = BigInt(0);
var K = BigInt(1);
BigInt(2);
var Qr = BigInt(3);
BigInt(4);
function Ac(t) {
  const e = vc(t), { Fp: n2 } = e, r = Kr(e.n, e.nBitLength), o2 = e.toBytes || ((p, d2, v2) => {
    const m = d2.toAffine();
    return ne(Uint8Array.from([4]), n2.toBytes(m.x), n2.toBytes(m.y));
  }), i2 = e.fromBytes || ((p) => {
    const d2 = p.subarray(1), v2 = n2.fromBytes(d2.subarray(0, n2.BYTES)), m = n2.fromBytes(d2.subarray(n2.BYTES, 2 * n2.BYTES));
    return { x: v2, y: m };
  });
  function s(p) {
    const { a: d2, b: v2 } = e, m = n2.sqr(p), O2 = n2.mul(m, p);
    return n2.add(n2.add(O2, n2.mul(p, d2)), v2);
  }
  if (!n2.eql(n2.sqr(e.Gy), s(e.Gx))) throw new Error("bad generator point: equation left != right");
  function c2(p) {
    return Ee(p, K, e.n);
  }
  function a(p) {
    const { allowedPrivateKeyLengths: d2, nByteLength: v2, wrapPrivateKey: m, n: O2 } = e;
    if (d2 && typeof p != "bigint") {
      if (St(p) && (p = Pt(p)), typeof p != "string" || !d2.includes(p.length)) throw new Error("invalid private key");
      p = p.padStart(v2 * 2, "0");
    }
    let N3;
    try {
      N3 = typeof p == "bigint" ? p : Ot(et("private key", p, v2));
    } catch {
      throw new Error("invalid private key, expected hex or " + v2 + " bytes, got " + typeof p);
    }
    return m && (N3 = X(N3, O2)), ft("private key", N3, K, O2), N3;
  }
  function u2(p) {
    if (!(p instanceof h2)) throw new Error("ProjectivePoint expected");
  }
  const l3 = tn((p, d2) => {
    const { px: v2, py: m, pz: O2 } = p;
    if (n2.eql(O2, n2.ONE)) return { x: v2, y: m };
    const N3 = p.is0();
    d2 == null && (d2 = N3 ? n2.ONE : n2.inv(O2));
    const $3 = n2.mul(v2, d2), B2 = n2.mul(m, d2), A2 = n2.mul(O2, d2);
    if (N3) return { x: n2.ZERO, y: n2.ZERO };
    if (!n2.eql(A2, n2.ONE)) throw new Error("invZ was invalid");
    return { x: $3, y: B2 };
  }), f2 = tn((p) => {
    if (p.is0()) {
      if (e.allowInfinityPoint && !n2.is0(p.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d2, y: v2 } = p.toAffine();
    if (!n2.isValid(d2) || !n2.isValid(v2)) throw new Error("bad point: x or y not FE");
    const m = n2.sqr(v2), O2 = s(d2);
    if (!n2.eql(m, O2)) throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class h2 {
    constructor(d2, v2, m) {
      if (this.px = d2, this.py = v2, this.pz = m, d2 == null || !n2.isValid(d2)) throw new Error("x required");
      if (v2 == null || !n2.isValid(v2)) throw new Error("y required");
      if (m == null || !n2.isValid(m)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(d2) {
      const { x: v2, y: m } = d2 || {};
      if (!d2 || !n2.isValid(v2) || !n2.isValid(m)) throw new Error("invalid affine point");
      if (d2 instanceof h2) throw new Error("projective point not allowed");
      const O2 = (N3) => n2.eql(N3, n2.ZERO);
      return O2(v2) && O2(m) ? h2.ZERO : new h2(v2, m, n2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d2) {
      const v2 = n2.invertBatch(d2.map((m) => m.pz));
      return d2.map((m, O2) => m.toAffine(v2[O2])).map(h2.fromAffine);
    }
    static fromHex(d2) {
      const v2 = h2.fromAffine(i2(et("pointHex", d2)));
      return v2.assertValidity(), v2;
    }
    static fromPrivateKey(d2) {
      return h2.BASE.multiply(a(d2));
    }
    static msm(d2, v2) {
      return hc(h2, r, d2, v2);
    }
    _setWindowSize(d2) {
      E4.setWindowSize(this, d2);
    }
    assertValidity() {
      f2(this);
    }
    hasEvenY() {
      const { y: d2 } = this.toAffine();
      if (n2.isOdd) return !n2.isOdd(d2);
      throw new Error("Field doesn't support isOdd");
    }
    equals(d2) {
      u2(d2);
      const { px: v2, py: m, pz: O2 } = this, { px: N3, py: $3, pz: B2 } = d2, A2 = n2.eql(n2.mul(v2, B2), n2.mul(N3, O2)), T2 = n2.eql(n2.mul(m, B2), n2.mul($3, O2));
      return A2 && T2;
    }
    negate() {
      return new h2(this.px, n2.neg(this.py), this.pz);
    }
    double() {
      const { a: d2, b: v2 } = e, m = n2.mul(v2, Qr), { px: O2, py: N3, pz: $3 } = this;
      let B2 = n2.ZERO, A2 = n2.ZERO, T2 = n2.ZERO, S2 = n2.mul(O2, O2), L2 = n2.mul(N3, N3), U4 = n2.mul($3, $3), _ = n2.mul(O2, N3);
      return _ = n2.add(_, _), T2 = n2.mul(O2, $3), T2 = n2.add(T2, T2), B2 = n2.mul(d2, T2), A2 = n2.mul(m, U4), A2 = n2.add(B2, A2), B2 = n2.sub(L2, A2), A2 = n2.add(L2, A2), A2 = n2.mul(B2, A2), B2 = n2.mul(_, B2), T2 = n2.mul(m, T2), U4 = n2.mul(d2, U4), _ = n2.sub(S2, U4), _ = n2.mul(d2, _), _ = n2.add(_, T2), T2 = n2.add(S2, S2), S2 = n2.add(T2, S2), S2 = n2.add(S2, U4), S2 = n2.mul(S2, _), A2 = n2.add(A2, S2), U4 = n2.mul(N3, $3), U4 = n2.add(U4, U4), S2 = n2.mul(U4, _), B2 = n2.sub(B2, S2), T2 = n2.mul(U4, L2), T2 = n2.add(T2, T2), T2 = n2.add(T2, T2), new h2(B2, A2, T2);
    }
    add(d2) {
      u2(d2);
      const { px: v2, py: m, pz: O2 } = this, { px: N3, py: $3, pz: B2 } = d2;
      let A2 = n2.ZERO, T2 = n2.ZERO, S2 = n2.ZERO;
      const L2 = e.a, U4 = n2.mul(e.b, Qr);
      let _ = n2.mul(v2, N3), j2 = n2.mul(m, $3), g = n2.mul(O2, B2), w = n2.add(v2, m), b3 = n2.add(N3, $3);
      w = n2.mul(w, b3), b3 = n2.add(_, j2), w = n2.sub(w, b3), b3 = n2.add(v2, O2);
      let I2 = n2.add(N3, B2);
      return b3 = n2.mul(b3, I2), I2 = n2.add(_, g), b3 = n2.sub(b3, I2), I2 = n2.add(m, O2), A2 = n2.add($3, B2), I2 = n2.mul(I2, A2), A2 = n2.add(j2, g), I2 = n2.sub(I2, A2), S2 = n2.mul(L2, b3), A2 = n2.mul(U4, g), S2 = n2.add(A2, S2), A2 = n2.sub(j2, S2), S2 = n2.add(j2, S2), T2 = n2.mul(A2, S2), j2 = n2.add(_, _), j2 = n2.add(j2, _), g = n2.mul(L2, g), b3 = n2.mul(U4, b3), j2 = n2.add(j2, g), g = n2.sub(_, g), g = n2.mul(L2, g), b3 = n2.add(b3, g), _ = n2.mul(j2, b3), T2 = n2.add(T2, _), _ = n2.mul(I2, b3), A2 = n2.mul(w, A2), A2 = n2.sub(A2, _), _ = n2.mul(w, j2), S2 = n2.mul(I2, S2), S2 = n2.add(S2, _), new h2(A2, T2, S2);
    }
    subtract(d2) {
      return this.add(d2.negate());
    }
    is0() {
      return this.equals(h2.ZERO);
    }
    wNAF(d2) {
      return E4.wNAFCached(this, d2, h2.normalizeZ);
    }
    multiplyUnsafe(d2) {
      const { endo: v2, n: m } = e;
      ft("scalar", d2, dt, m);
      const O2 = h2.ZERO;
      if (d2 === dt) return O2;
      if (this.is0() || d2 === K) return this;
      if (!v2 || E4.hasPrecomputes(this)) return E4.wNAFCachedUnsafe(this, d2, h2.normalizeZ);
      let { k1neg: N3, k1: $3, k2neg: B2, k2: A2 } = v2.splitScalar(d2), T2 = O2, S2 = O2, L2 = this;
      for (; $3 > dt || A2 > dt; ) $3 & K && (T2 = T2.add(L2)), A2 & K && (S2 = S2.add(L2)), L2 = L2.double(), $3 >>= K, A2 >>= K;
      return N3 && (T2 = T2.negate()), B2 && (S2 = S2.negate()), S2 = new h2(n2.mul(S2.px, v2.beta), S2.py, S2.pz), T2.add(S2);
    }
    multiply(d2) {
      const { endo: v2, n: m } = e;
      ft("scalar", d2, K, m);
      let O2, N3;
      if (v2) {
        const { k1neg: $3, k1: B2, k2neg: A2, k2: T2 } = v2.splitScalar(d2);
        let { p: S2, f: L2 } = this.wNAF(B2), { p: U4, f: _ } = this.wNAF(T2);
        S2 = E4.constTimeNegate($3, S2), U4 = E4.constTimeNegate(A2, U4), U4 = new h2(n2.mul(U4.px, v2.beta), U4.py, U4.pz), O2 = S2.add(U4), N3 = L2.add(_);
      } else {
        const { p: $3, f: B2 } = this.wNAF(d2);
        O2 = $3, N3 = B2;
      }
      return h2.normalizeZ([O2, N3])[0];
    }
    multiplyAndAddUnsafe(d2, v2, m) {
      const O2 = h2.BASE, N3 = (B2, A2) => A2 === dt || A2 === K || !B2.equals(O2) ? B2.multiplyUnsafe(A2) : B2.multiply(A2), $3 = N3(this, v2).add(N3(d2, m));
      return $3.is0() ? void 0 : $3;
    }
    toAffine(d2) {
      return l3(this, d2);
    }
    isTorsionFree() {
      const { h: d2, isTorsionFree: v2 } = e;
      if (d2 === K) return true;
      if (v2) return v2(h2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: d2, clearCofactor: v2 } = e;
      return d2 === K ? this : v2 ? v2(h2, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(d2 = true) {
      return Ct("isCompressed", d2), this.assertValidity(), o2(h2, this, d2);
    }
    toHex(d2 = true) {
      return Ct("isCompressed", d2), Pt(this.toRawBytes(d2));
    }
  }
  h2.BASE = new h2(e.Gx, e.Gy, n2.ONE), h2.ZERO = new h2(n2.ZERO, n2.ONE, n2.ZERO);
  const y3 = e.nBitLength, E4 = dc(h2, e.endo ? Math.ceil(y3 / 2) : y3);
  return { CURVE: e, ProjectivePoint: h2, normPrivateKeyToScalar: a, weierstrassEquation: s, isWithinCurveOrder: c2 };
}
function Bc(t) {
  const e = Wr(t);
  return Dt(e, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...e });
}
function Ic(t) {
  const e = Bc(t), { Fp: n2, n: r } = e, o2 = n2.BYTES + 1, i2 = 2 * n2.BYTES + 1;
  function s(g) {
    return X(g, r);
  }
  function c2(g) {
    return nn(g, r);
  }
  const { ProjectivePoint: a, normPrivateKeyToScalar: u2, weierstrassEquation: l3, isWithinCurveOrder: f2 } = Ac({ ...e, toBytes(g, w, b3) {
    const I2 = w.toAffine(), R2 = n2.toBytes(I2.x), x2 = ne;
    return Ct("isCompressed", b3), b3 ? x2(Uint8Array.from([w.hasEvenY() ? 2 : 3]), R2) : x2(Uint8Array.from([4]), R2, n2.toBytes(I2.y));
  }, fromBytes(g) {
    const w = g.length, b3 = g[0], I2 = g.subarray(1);
    if (w === o2 && (b3 === 2 || b3 === 3)) {
      const R2 = Ot(I2);
      if (!Ee(R2, K, n2.ORDER)) throw new Error("Point is not on curve");
      const x2 = l3(R2);
      let C5;
      try {
        C5 = n2.sqrt(x2);
      } catch (M3) {
        const D2 = M3 instanceof Error ? ": " + M3.message : "";
        throw new Error("Point is not on curve" + D2);
      }
      const P = (C5 & K) === K;
      return (b3 & 1) === 1 !== P && (C5 = n2.neg(C5)), { x: R2, y: C5 };
    } else if (w === i2 && b3 === 4) {
      const R2 = n2.fromBytes(I2.subarray(0, n2.BYTES)), x2 = n2.fromBytes(I2.subarray(n2.BYTES, 2 * n2.BYTES));
      return { x: R2, y: x2 };
    } else {
      const R2 = o2, x2 = i2;
      throw new Error("invalid Point, expected length of " + R2 + ", or uncompressed " + x2 + ", got " + w);
    }
  } }), h2 = (g) => Pt(Mt(g, e.nByteLength));
  function y3(g) {
    const w = r >> K;
    return g > w;
  }
  function E4(g) {
    return y3(g) ? s(-g) : g;
  }
  const p = (g, w, b3) => Ot(g.slice(w, b3));
  class d2 {
    constructor(w, b3, I2) {
      this.r = w, this.s = b3, this.recovery = I2, this.assertValidity();
    }
    static fromCompact(w) {
      const b3 = e.nByteLength;
      return w = et("compactSignature", w, b3 * 2), new d2(p(w, 0, b3), p(w, b3, 2 * b3));
    }
    static fromDER(w) {
      const { r: b3, s: I2 } = lt.toSig(et("DER", w));
      return new d2(b3, I2);
    }
    assertValidity() {
      ft("r", this.r, K, r), ft("s", this.s, K, r);
    }
    addRecoveryBit(w) {
      return new d2(this.r, this.s, w);
    }
    recoverPublicKey(w) {
      const { r: b3, s: I2, recovery: R2 } = this, x2 = B2(et("msgHash", w));
      if (R2 == null || ![0, 1, 2, 3].includes(R2)) throw new Error("recovery id invalid");
      const C5 = R2 === 2 || R2 === 3 ? b3 + e.n : b3;
      if (C5 >= n2.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const P = (R2 & 1) === 0 ? "02" : "03", k4 = a.fromHex(P + h2(C5)), M3 = c2(C5), D2 = s(-x2 * M3), z = s(I2 * M3), Z = a.BASE.multiplyAndAddUnsafe(k4, D2, z);
      if (!Z) throw new Error("point at infinify");
      return Z.assertValidity(), Z;
    }
    hasHighS() {
      return y3(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new d2(this.r, s(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return Vt(this.toDERHex());
    }
    toDERHex() {
      return lt.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return Vt(this.toCompactHex());
    }
    toCompactHex() {
      return h2(this.r) + h2(this.s);
    }
  }
  const v2 = { isValidPrivateKey(g) {
    try {
      return u2(g), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: u2, randomPrivateKey: () => {
    const g = zr(e.n);
    return uc(e.randomBytes(g), e.n);
  }, precompute(g = 8, w = a.BASE) {
    return w._setWindowSize(g), w.multiply(BigInt(3)), w;
  } };
  function m(g, w = true) {
    return a.fromPrivateKey(g).toRawBytes(w);
  }
  function O2(g) {
    const w = St(g), b3 = typeof g == "string", I2 = (w || b3) && g.length;
    return w ? I2 === o2 || I2 === i2 : b3 ? I2 === 2 * o2 || I2 === 2 * i2 : g instanceof a;
  }
  function N3(g, w, b3 = true) {
    if (O2(g)) throw new Error("first arg must be private key");
    if (!O2(w)) throw new Error("second arg must be public key");
    return a.fromHex(w).multiply(u2(g)).toRawBytes(b3);
  }
  const $3 = e.bits2int || function(g) {
    if (g.length > 8192) throw new Error("input is too large");
    const w = Ot(g), b3 = g.length * 8 - e.nBitLength;
    return b3 > 0 ? w >> BigInt(b3) : w;
  }, B2 = e.bits2int_modN || function(g) {
    return s($3(g));
  }, A2 = Je(e.nBitLength);
  function T2(g) {
    return ft("num < 2^" + e.nBitLength, g, dt, A2), Mt(g, e.nByteLength);
  }
  function S2(g, w, b3 = L2) {
    if (["recovered", "canonical"].some((W2) => W2 in b3)) throw new Error("sign() legacy options not supported");
    const { hash: I2, randomBytes: R2 } = e;
    let { lowS: x2, prehash: C5, extraEntropy: P } = b3;
    x2 == null && (x2 = true), g = et("msgHash", g), Jr(b3), C5 && (g = et("prehashed msgHash", I2(g)));
    const k4 = B2(g), M3 = u2(w), D2 = [T2(M3), T2(k4)];
    if (P != null && P !== false) {
      const W2 = P === true ? R2(n2.BYTES) : P;
      D2.push(et("extraEntropy", W2));
    }
    const z = ne(...D2), Z = k4;
    function st2(W2) {
      const J3 = $3(W2);
      if (!f2(J3)) return;
      const Be3 = c2(J3), zt2 = a.BASE.multiply(J3).toAffine(), vt2 = s(zt2.x);
      if (vt2 === dt) return;
      const Zt2 = s(Be3 * s(Z + vt2 * M3));
      if (Zt2 === dt) return;
      let Ut2 = (zt2.x === vt2 ? 0 : 2) | Number(zt2.y & K), vn = Zt2;
      return x2 && y3(Zt2) && (vn = E4(Zt2), Ut2 ^= 1), new d2(vt2, vn, Ut2);
    }
    return { seed: z, k2sig: st2 };
  }
  const L2 = { lowS: e.lowS, prehash: false }, U4 = { lowS: e.lowS, prehash: false };
  function _(g, w, b3 = L2) {
    const { seed: I2, k2sig: R2 } = S2(g, w, b3), x2 = e;
    return Vr(x2.hash.outputLen, x2.nByteLength, x2.hmac)(I2, R2);
  }
  a.BASE._setWindowSize(8);
  function j2(g, w, b3, I2 = U4) {
    const R2 = g;
    w = et("msgHash", w), b3 = et("publicKey", b3);
    const { lowS: x2, prehash: C5, format: P } = I2;
    if (Jr(I2), "strict" in I2) throw new Error("options.strict was renamed to lowS");
    if (P !== void 0 && P !== "compact" && P !== "der") throw new Error("format must be compact or der");
    const k4 = typeof R2 == "string" || St(R2), M3 = !k4 && !P && typeof R2 == "object" && R2 !== null && typeof R2.r == "bigint" && typeof R2.s == "bigint";
    if (!k4 && !M3) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let D2, z;
    try {
      if (M3 && (D2 = new d2(R2.r, R2.s)), k4) {
        try {
          P !== "compact" && (D2 = d2.fromDER(R2));
        } catch (Ut2) {
          if (!(Ut2 instanceof lt.Err)) throw Ut2;
        }
        !D2 && P !== "der" && (D2 = d2.fromCompact(R2));
      }
      z = a.fromHex(b3);
    } catch {
      return false;
    }
    if (!D2 || x2 && D2.hasHighS()) return false;
    C5 && (w = e.hash(w));
    const { r: Z, s: st2 } = D2, W2 = B2(w), J3 = c2(st2), Be3 = s(W2 * J3), zt2 = s(Z * J3), vt2 = a.BASE.multiplyAndAddUnsafe(z, Be3, zt2)?.toAffine();
    return vt2 ? s(vt2.x) === Z : false;
  }
  return { CURVE: e, getPublicKey: m, getSharedSecret: N3, sign: _, verify: j2, ProjectivePoint: a, Signature: d2, utils: v2 };
}
function Nc(t) {
  return { hash: t, hmac: (e, ...n2) => ye(t, e, Vi(...n2)), randomBytes: Lt };
}
function Uc(t, e) {
  const n2 = (r) => Ic({ ...t, ...Nc(r) });
  return { ...n2(e), create: n2 };
}
var to = Kr(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var Tc = to.create(BigInt("-3"));
var Rc = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var _c = Uc({ a: Tc, b: Rc, Fp: to, n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"), h: BigInt(1), lowS: false }, Qt);
var G2 = "base16";
var qt = "base64pad";
var xe = "base64url";
var Kt = "utf8";
var Ft = 1;
var re2 = 2;
function Pc(t) {
  const e = Qt(fromString(t, G2));
  return toString(e, G2);
}
function kc(t) {
  const e = Qt(fromString(t, Kt));
  return toString(e, G2);
}
function Xc(t, e, n2) {
  return `${t}?wc_ev=${n2}&topic=${e}`;
}
var Jc = Object.defineProperty;
var Qc = Object.defineProperties;
var ta = Object.getOwnPropertyDescriptors;
var fo = Object.getOwnPropertySymbols;
var ea = Object.prototype.hasOwnProperty;
var na = Object.prototype.propertyIsEnumerable;
var lo = (t, e, n2) => e in t ? Jc(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var ra = (t, e) => {
  for (var n2 in e || (e = {})) ea.call(e, n2) && lo(t, n2, e[n2]);
  if (fo) for (var n2 of fo(e)) na.call(e, n2) && lo(t, n2, e[n2]);
  return t;
};
var oa = (t, e) => Qc(t, ta(e));
function It(t) {
  const e = [];
  return t.forEach((n2) => {
    const [r, o2] = n2.split(":");
    e.push(`${r}:${o2}`);
  }), e;
}
function ho(t) {
  const e = [];
  return Object.values(t).forEach((n2) => {
    e.push(...It(n2.accounts));
  }), e;
}
function po(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r) => {
    It(r.accounts).includes(e) && n2.push(...r.methods);
  }), n2;
}
function go(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r) => {
    It(r.accounts).includes(e) && n2.push(...r.events);
  }), n2;
}
function yn(t) {
  return t.includes(":");
}
function yo(t) {
  return yn(t) ? t.split(":")[0] : t;
}
function ie(t) {
  var e, n2, r;
  const o2 = {};
  if (!Oe(t)) return o2;
  for (const [i2, s] of Object.entries(t)) {
    const c2 = yn(i2) ? [i2] : s.chains, a = s.methods || [], u2 = s.events || [], l3 = yo(i2);
    o2[l3] = oa(ra({}, o2[l3]), { chains: ot(c2, (e = o2[l3]) == null ? void 0 : e.chains), methods: ot(a, (n2 = o2[l3]) == null ? void 0 : n2.methods), events: ot(u2, (r = o2[l3]) == null ? void 0 : r.events) });
  }
  return o2;
}
function mo(t) {
  const e = {};
  return t?.forEach((n2) => {
    var r;
    const [o2, i2] = n2.split(":");
    e[o2] || (e[o2] = { accounts: [], chains: [], events: [], methods: [] }), e[o2].accounts.push(n2), (r = e[o2].chains) == null || r.push(`${o2}:${i2}`);
  }), e;
}
function ca(t, e) {
  e = e.map((r) => r.replace("did:pkh:", ""));
  const n2 = mo(e);
  for (const [r, o2] of Object.entries(n2)) o2.methods ? o2.methods = ot(o2.methods, t) : o2.methods = t, o2.events = ["chainChanged", "accountsChanged"];
  return n2;
}
function aa(t, e) {
  var n2, r, o2, i2, s, c2;
  const a = ie(t), u2 = ie(e), l3 = {}, f2 = Object.keys(a).concat(Object.keys(u2));
  for (const h2 of f2) l3[h2] = { chains: ot((n2 = a[h2]) == null ? void 0 : n2.chains, (r = u2[h2]) == null ? void 0 : r.chains), methods: ot((o2 = a[h2]) == null ? void 0 : o2.methods, (i2 = u2[h2]) == null ? void 0 : i2.methods), events: ot((s = a[h2]) == null ? void 0 : s.events, (c2 = u2[h2]) == null ? void 0 : c2.events) };
  return l3;
}
var wo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var bo = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ht(t, e) {
  const { message: n2, code: r } = bo[t];
  return { message: e ? `${n2} ${e}` : n2, code: r };
}
function Nt(t, e) {
  const { message: n2, code: r } = wo[t];
  return { message: e ? `${n2} ${e}` : n2, code: r };
}
function se(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : true : false;
}
function Oe(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function Et(t) {
  return typeof t > "u";
}
function nt(t, e) {
  return e && Et(t) ? true : typeof t == "string" && !!t.trim().length;
}
function Ae(t, e) {
  return e && Et(t) ? true : typeof t == "number" && !isNaN(t);
}
function ua(t, e) {
  const { requiredNamespaces: n2 } = e, r = Object.keys(t.namespaces), o2 = Object.keys(n2);
  let i2 = true;
  return gt(o2, r) ? (r.forEach((s) => {
    const { accounts: c2, methods: a, events: u2 } = t.namespaces[s], l3 = It(c2), f2 = n2[s];
    (!gt(ue2(s, f2), l3) || !gt(f2.methods, a) || !gt(f2.events, u2)) && (i2 = false);
  }), i2) : false;
}
function ce(t) {
  return nt(t, false) && t.includes(":") ? t.split(":").length === 2 : false;
}
function Eo(t) {
  if (nt(t, false) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n2 = e[0] + ":" + e[1];
      return !!e[2] && ce(n2);
    }
  }
  return false;
}
function ha(t, e) {
  let n2 = null;
  return nt(t?.publicKey, false) || (n2 = ht("MISSING_OR_INVALID", `${e} controller public key should be a string`)), n2;
}
function mn(t) {
  let e = true;
  return se(t) ? t.length && (e = t.every((n2) => nt(n2, false))) : e = false, e;
}
function vo(t, e, n2) {
  let r = null;
  return se(e) && e.length ? e.forEach((o2) => {
    r || ce(o2) || (r = Nt("UNSUPPORTED_CHAINS", `${n2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : ce(t) || (r = Nt("UNSUPPORTED_CHAINS", `${n2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function xo(t, e, n2) {
  let r = null;
  return Object.entries(t).forEach(([o2, i2]) => {
    if (r) return;
    const s = vo(o2, ue2(o2, i2), `${e} ${n2}`);
    s && (r = s);
  }), r;
}
function So(t, e) {
  let n2 = null;
  return se(t) ? t.forEach((r) => {
    n2 || Eo(r) || (n2 = Nt("UNSUPPORTED_ACCOUNTS", `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : n2 = Nt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n2;
}
function Oo(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r) => {
    if (n2) return;
    const o2 = So(r?.accounts, `${e} namespace`);
    o2 && (n2 = o2);
  }), n2;
}
function Ao(t, e) {
  let n2 = null;
  return mn(t?.methods) ? mn(t?.events) || (n2 = Nt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : n2 = Nt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), n2;
}
function wn(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r) => {
    if (n2) return;
    const o2 = Ao(r, `${e}, namespace`);
    o2 && (n2 = o2);
  }), n2;
}
function pa(t, e, n2) {
  let r = null;
  if (t && Oe(t)) {
    const o2 = wn(t, e);
    o2 && (r = o2);
    const i2 = xo(t, e, n2);
    i2 && (r = i2);
  } else r = ht("MISSING_OR_INVALID", `${e}, ${n2} should be an object with data`);
  return r;
}
function Bo(t, e) {
  let n2 = null;
  if (t && Oe(t)) {
    const r = wn(t, e);
    r && (n2 = r);
    const o2 = Oo(t, e);
    o2 && (n2 = o2);
  } else n2 = ht("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return n2;
}
function Io(t) {
  return nt(t.protocol, true);
}
function ga(t, e) {
  let n2 = false;
  return e && !t ? n2 = true : t && se(t) && t.length && t.forEach((r) => {
    n2 = Io(r);
  }), n2;
}
function ya(t) {
  return typeof t == "number";
}
function ma(t) {
  return typeof t < "u" && typeof t !== null;
}
function wa(t) {
  return !(!t || typeof t != "object" || !t.code || !Ae(t.code, false) || !t.message || !nt(t.message, false));
}
function ba(t) {
  return !(Et(t) || !nt(t.method, false));
}
function Ea(t) {
  return !(Et(t) || Et(t.result) && Et(t.error) || !Ae(t.id, false) || !nt(t.jsonrpc, false));
}
function va(t) {
  return !(Et(t) || !nt(t.name, false));
}
function xa(t, e) {
  return !(!ce(e) || !ho(t).includes(e));
}
function Sa(t, e, n2) {
  return nt(n2, false) ? po(t, e).includes(n2) : false;
}
function Oa(t, e, n2) {
  return nt(n2, false) ? go(t, e).includes(n2) : false;
}
function No(t, e, n2) {
  let r = null;
  const o2 = Aa(t), i2 = Ba(e), s = Object.keys(o2), c2 = Object.keys(i2), a = Uo(Object.keys(t)), u2 = Uo(Object.keys(e)), l3 = a.filter((f2) => !u2.includes(f2));
  return l3.length && (r = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l3.toString()}
      Received: ${Object.keys(e).toString()}`)), gt(s, c2) || (r = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces chains don't satisfy required namespaces.
      Required: ${s.toString()}
      Approved: ${c2.toString()}`)), Object.keys(e).forEach((f2) => {
    if (!f2.includes(":") || r) return;
    const h2 = It(e[f2].accounts);
    h2.includes(f2) || (r = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces accounts don't satisfy namespace accounts for ${f2}
        Required: ${f2}
        Approved: ${h2.toString()}`));
  }), s.forEach((f2) => {
    r || (gt(o2[f2].methods, i2[f2].methods) ? gt(o2[f2].events, i2[f2].events) || (r = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces events don't satisfy namespace events for ${f2}`)) : r = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces methods don't satisfy namespace methods for ${f2}`));
  }), r;
}
function Aa(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    var r;
    n2.includes(":") ? e[n2] = t[n2] : (r = t[n2].chains) == null || r.forEach((o2) => {
      e[o2] = { methods: t[n2].methods, events: t[n2].events };
    });
  }), e;
}
function Uo(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Ba(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    if (n2.includes(":")) e[n2] = t[n2];
    else {
      const r = It(t[n2].accounts);
      r?.forEach((o2) => {
        e[o2] = { accounts: t[n2].accounts.filter((i2) => i2.includes(`${o2}:`)), methods: t[n2].methods, events: t[n2].events };
      });
    }
  }), e;
}
function Ia(t, e) {
  return Ae(t, false) && t <= e.max && t >= e.min;
}
var bn = {};
var Ra = class {
  static get(e) {
    return bn[e];
  }
  static set(e, n2) {
    bn[e] = n2;
  }
  static delete(e) {
    delete bn[e];
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events3 = __toESM(require_events());
var De2 = "wc";
var Le = 2;
var ke2 = "client";
var we2 = `${De2}@${Le}:${ke2}:`;
var me2 = { name: ke2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Me2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var pt2 = "proposal";
var $e = "Proposal expired";
var ht2 = "session";
var J2 = import_time2.SEVEN_DAYS;
var dt2 = "engine";
var N = { wc_sessionPropose: { req: { ttl: import_time2.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time2.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time2.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time2.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time2.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time2.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e2 = { min: import_time2.FIVE_MINUTES, max: import_time2.SEVEN_DAYS };
var $ = { idle: "IDLE", active: "ACTIVE" };
var Ke2 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } };
var ut2 = "request";
var gt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var yt2 = "wc";
var wt2 = "auth";
var mt2 = "authKeys";
var _t2 = "pairingTopics";
var Et2 = "requests";
var ae2 = `${yt2}@${1.5}:${wt2}:`;
var ce2 = `${ae2}:PUB_KEY`;
var vs2 = Object.defineProperty;
var Is2 = Object.defineProperties;
var Ts2 = Object.getOwnPropertyDescriptors;
var ft2 = Object.getOwnPropertySymbols;
var qs2 = Object.prototype.hasOwnProperty;
var Ps = Object.prototype.propertyIsEnumerable;
var Ue = (S2, n2, e) => n2 in S2 ? vs2(S2, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S2[n2] = e;
var v = (S2, n2) => {
  for (var e in n2 || (n2 = {})) qs2.call(n2, e) && Ue(S2, e, n2[e]);
  if (ft2) for (var e of ft2(n2)) Ps.call(n2, e) && Ue(S2, e, n2[e]);
  return S2;
};
var b = (S2, n2) => Is2(S2, Ts2(n2));
var c = (S2, n2, e) => Ue(S2, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ns2 = class extends V {
  constructor(n2) {
    super(n2), c(this, "name", dt2), c(this, "events", new import_events3.default()), c(this, "initialized", false), c(this, "requestQueue", { state: $.idle, queue: [] }), c(this, "sessionRequestQueue", { state: $.idle, queue: [] }), c(this, "requestQueueDelay", import_time2.ONE_SECOND), c(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c(this, "recentlyDeletedLimit", 200), c(this, "relayMessageCache", []), c(this, "pendingSessions", /* @__PURE__ */ new Map()), c(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time2.toMiliseconds)(this.requestQueueDelay)));
    }), c(this, "connect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = b(v({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t), t.optionalNamespaces = aa(t.requiredNamespaces, t.optionalNamespaces), t.requiredNamespaces = {};
      const { pairingTopic: s, requiredNamespaces: i2, optionalNamespaces: r, sessionProperties: o2, scopedProperties: a, relays: l3 } = t;
      let p = s, h2, u2 = false;
      try {
        if (p) {
          const T2 = this.client.core.pairing.pairings.get(p);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u2 = T2.active;
        }
      } catch (T2) {
        throw this.client.logger.error(`connect() -> pairing.get(${p}) failed`), T2;
      }
      if (!p || !u2) {
        const { topic: T2, uri: K3 } = await this.client.core.pairing.create();
        p = T2, h2 = K3;
      }
      if (!p) {
        const { message: T2 } = ht("NO_MATCHING_KEY", `connect() pairing topic: ${p}`);
        throw new Error(T2);
      }
      const d2 = await this.client.core.crypto.generateKeyPair(), w = N.wc_sessionPropose.req.ttl || import_time2.FIVE_MINUTES, m = Ei(w), f2 = b(v(v({ requiredNamespaces: i2, optionalNamespaces: r, relays: l3 ?? [{ protocol: xt }], proposer: { publicKey: d2, metadata: this.client.metadata }, expiryTimestamp: m, pairingTopic: p }, o2 && { sessionProperties: o2 }), a && { scopedProperties: a }), { id: payloadId() }), _ = xi("session_connect", f2.id), { reject: g, resolve: A2, done: D2 } = gi(w, $e), I2 = ({ id: T2 }) => {
        T2 === f2.id && (this.client.events.off("proposal_expire", I2), this.pendingSessions.delete(f2.id), this.events.emit(_, { error: { message: $e, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", I2), this.events.once(_, ({ error: T2, session: K3 }) => {
        this.client.events.off("proposal_expire", I2), T2 ? g(T2) : K3 && A2(K3);
      }), await this.sendRequest({ topic: p, method: "wc_sessionPropose", params: f2, throwOnFailedPublish: true, clientRpcId: f2.id }), await this.setProposal(f2.id, f2), { uri: h2, approval: D2 };
    }), c(this, "pair", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }), c(this, "approve", async (e) => {
      var t, s, i2;
      const r = this.client.core.eventClient.createEvent({ properties: { topic: (t = e?.id) == null ? void 0 : t.toString(), trace: [er.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q3) {
        throw r.setError(tr.no_internet_connection), q3;
      }
      try {
        await this.isValidProposalId(e?.id);
      } catch (q3) {
        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r.setError(tr.proposal_not_found), q3;
      }
      try {
        await this.isValidApprove(e);
      } catch (q3) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r.setError(tr.session_approve_namespace_validation_failure), q3;
      }
      const { id: o2, relayProtocol: a, namespaces: l3, sessionProperties: p, scopedProperties: h2, sessionConfig: u2 } = e, d2 = this.client.proposal.get(o2);
      this.client.core.eventClient.deleteEvent({ eventId: r.eventId });
      const { pairingTopic: w, proposer: m, requiredNamespaces: f2, optionalNamespaces: _ } = d2;
      let g = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: w });
      g || (g = (i2 = this.client.core.eventClient) == null ? void 0 : i2.createEvent({ type: er.session_approve_started, properties: { topic: w, trace: [er.session_approve_started, er.session_namespaces_validation_success] } }));
      const A2 = await this.client.core.crypto.generateKeyPair(), D2 = m.publicKey, I2 = await this.client.core.crypto.generateSharedKey(A2, D2), T2 = v(v(v({ relay: { protocol: a ?? "irn" }, namespaces: l3, controller: { publicKey: A2, metadata: this.client.metadata }, expiry: Ei(J2) }, p && { sessionProperties: p }), h2 && { scopedProperties: h2 }), u2 && { sessionConfig: u2 }), K3 = Q.relay;
      g.addTrace(er.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(I2, { transportType: K3 });
      } catch (q3) {
        throw g.setError(tr.subscribe_session_topic_failure), q3;
      }
      g.addTrace(er.subscribe_session_topic_success);
      const fe2 = b(v({}, T2), { topic: I2, requiredNamespaces: f2, optionalNamespaces: _, pairingTopic: w, acknowledged: false, self: T2.controller, peer: { publicKey: m.publicKey, metadata: m.metadata }, controller: A2, transportType: Q.relay });
      await this.client.session.set(I2, fe2), g.addTrace(er.store_session);
      try {
        g.addTrace(er.publishing_session_settle), await this.sendRequest({ topic: I2, method: "wc_sessionSettle", params: T2, throwOnFailedPublish: true }).catch((q3) => {
          throw g?.setError(tr.session_settle_publish_failure), q3;
        }), g.addTrace(er.session_settle_publish_success), g.addTrace(er.publishing_session_approve), await this.sendResult({ id: o2, topic: w, result: { relay: { protocol: a ?? "irn" }, responderPublicKey: A2 }, throwOnFailedPublish: true }).catch((q3) => {
          throw g?.setError(tr.session_approve_publish_failure), q3;
        }), g.addTrace(er.session_approve_publish_success);
      } catch (q3) {
        throw this.client.logger.error(q3), this.client.session.delete(I2, Nt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I2), q3;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: g.eventId }), await this.client.core.pairing.updateMetadata({ topic: w, metadata: m.metadata }), await this.client.proposal.delete(o2, Nt("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: w }), await this.setExpiry(I2, Ei(J2)), { topic: I2, acknowledged: () => Promise.resolve(this.client.session.get(I2)) };
    }), c(this, "reject", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r;
      }
      const { id: t, reason: s } = e;
      let i2;
      try {
        i2 = this.client.proposal.get(t).pairingTopic;
      } catch (r) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r;
      }
      i2 && (await this.sendError({ id: t, topic: i2, error: s, rpcOpts: N.wc_sessionPropose.reject }), await this.client.proposal.delete(t, Nt("USER_DISCONNECTED")));
    }), c(this, "update", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (h2) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h2;
      }
      const { topic: t, namespaces: s } = e, { done: i2, resolve: r, reject: o2 } = gi(), a = payloadId(), l3 = getBigIntRpcId().toString(), p = this.client.session.get(t).namespaces;
      return this.events.once(xi("session_update", a), ({ error: h2 }) => {
        h2 ? o2(h2) : r();
      }), await this.client.session.update(t, { namespaces: s }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: true, clientRpcId: a, relayRpcId: l3 }).catch((h2) => {
        this.client.logger.error(h2), this.client.session.update(t, { namespaces: p }), o2(h2);
      }), { acknowledged: i2 };
    }), c(this, "extend", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a;
      }
      const { topic: t } = e, s = payloadId(), { done: i2, resolve: r, reject: o2 } = gi();
      return this.events.once(xi("session_extend", s), ({ error: a }) => {
        a ? o2(a) : r();
      }), await this.setExpiry(t, Ei(J2)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: true }).catch((a) => {
        o2(a);
      }), { acknowledged: i2 };
    }), c(this, "request", async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (_) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), _;
      }
      const { chainId: t, request: s, topic: i2, expiry: r = N.wc_sessionRequest.req.ttl } = e, o2 = this.client.session.get(i2);
      o2?.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const a = payloadId(), l3 = getBigIntRpcId().toString(), { done: p, resolve: h2, reject: u2 } = gi(r, "Request expired. Please try again.");
      this.events.once(xi("session_request", a), ({ error: _, result: g }) => {
        _ ? u2(_) : h2(g);
      });
      const d2 = "wc_sessionRequest", w = this.getAppLinkIfEnabled(o2.peer.metadata, o2.transportType);
      if (w) return await this.sendRequest({ clientRpcId: a, relayRpcId: l3, topic: i2, method: d2, params: { request: b(v({}, s), { expiryTimestamp: Ei(r) }), chainId: t }, expiry: r, throwOnFailedPublish: true, appLink: w }).catch((_) => u2(_)), this.client.events.emit("session_request_sent", { topic: i2, request: s, chainId: t, id: a }), await p();
      const m = { request: b(v({}, s), { expiryTimestamp: Ei(r) }), chainId: t }, f2 = this.shouldSetTVF(d2, m);
      return await Promise.all([new Promise(async (_) => {
        await this.sendRequest(v({ clientRpcId: a, relayRpcId: l3, topic: i2, method: d2, params: m, expiry: r, throwOnFailedPublish: true }, f2 && { tvf: this.getTVFParams(a, m) })).catch((g) => u2(g)), this.client.events.emit("session_request_sent", { topic: i2, request: s, chainId: t, id: a }), _();
      }), new Promise(async (_) => {
        var g;
        if (!((g = o2.sessionConfig) != null && g.disableDeepLink)) {
          const A2 = await Oi(this.client.core.storage, Me2);
          await Si({ id: a, topic: i2, wcDeepLink: A2 });
        }
        _();
      }), p()]).then((_) => _[2]);
    }), c(this, "respond", async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s } = e, { id: i2 } = s, r = this.client.session.get(t);
      r.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const o2 = this.getAppLinkIfEnabled(r.peer.metadata, r.transportType);
      isJsonRpcResult(s) ? await this.sendResult({ id: i2, topic: t, result: s.result, throwOnFailedPublish: true, appLink: o2 }) : isJsonRpcError(s) && await this.sendError({ id: i2, topic: t, error: s.error, appLink: o2 }), this.cleanupAfterResponse(e);
    }), c(this, "ping", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s = payloadId(), i2 = getBigIntRpcId().toString(), { done: r, resolve: o2, reject: a } = gi();
        this.events.once(xi("session_ping", s), ({ error: l3 }) => {
          l3 ? a(l3) : o2();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s, relayRpcId: i2 }), r()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
    }), c(this, "emit", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s, chainId: i2 } = e, r = getBigIntRpcId().toString(), o2 = payloadId();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s, chainId: i2 }, throwOnFailedPublish: true, relayRpcId: r, clientRpcId: o2 });
    }), c(this, "disconnect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: Nt("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s } = ht("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s);
      }
    }), c(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => ua(t, e)))), c(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c(this, "authenticate", async (e, t) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i2 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), r = i2 ? Q.link_mode : Q.relay;
      r === Q.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o2, statement: a = "", uri: l3, domain: p, nonce: h2, type: u2, exp: d2, nbf: w, methods: m = [], expiry: f2 } = e, _ = [...e.resources || []], { topic: g, uri: A2 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: g, uri: A2 } });
      const D2 = await this.client.core.crypto.generateKeyPair(), I2 = Pc(D2);
      if (await Promise.all([this.client.auth.authKeys.set(ce2, { responseTopic: I2, publicKey: D2 }), this.client.auth.pairingTopics.set(I2, { topic: I2, pairingTopic: g })]), await this.client.core.relayer.subscribe(I2, { transportType: r }), this.client.logger.info(`sending request to new pairing topic: ${g}`), m.length > 0) {
        const { namespace: x2 } = Ne(o2[0]);
        let L2 = fs(x2, "request", m);
        pe(_) && (L2 = ls(L2, _.pop())), _.push(L2);
      }
      const T2 = f2 && f2 > N.wc_sessionAuthenticate.req.ttl ? f2 : N.wc_sessionAuthenticate.req.ttl, K3 = { authPayload: { type: u2 ?? "caip122", chains: o2, statement: a, aud: l3, domain: p, version: "1", nonce: h2, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d2, nbf: w, resources: _ }, requester: { publicKey: D2, metadata: this.client.metadata }, expiryTimestamp: Ei(T2) }, fe2 = { eip155: { chains: o2, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m])], events: ["chainChanged", "accountsChanged"] } }, q3 = { requiredNamespaces: {}, optionalNamespaces: fe2, relays: [{ protocol: "irn" }], pairingTopic: g, proposer: { publicKey: D2, metadata: this.client.metadata }, expiryTimestamp: Ei(N.wc_sessionPropose.req.ttl), id: payloadId() }, { done: Rt3, resolve: je2, reject: Se2 } = gi(T2, "Request expired"), te3 = payloadId(), le3 = xi("session_connect", q3.id), Re2 = xi("session_request", te3), pe3 = async ({ error: x2, session: L2 }) => {
        this.events.off(Re2, ve3), x2 ? Se2(x2) : L2 && je2({ session: L2 });
      }, ve3 = async (x2) => {
        var L2, Fe3, Qe3;
        if (await this.deletePendingAuthRequest(te3, { message: "fulfilled", code: 0 }), x2.error) {
          const ie3 = Nt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return x2.error.code === ie3.code ? void 0 : (this.events.off(le3, pe3), Se2(x2.error.message));
        }
        await this.deleteProposal(q3.id), this.events.off(le3, pe3);
        const { cacaos: He3, responder: Q3 } = x2.result, Te2 = [], ze3 = [];
        for (const ie3 of He3) {
          await is({ cacao: ie3, projectId: this.client.core.projectId }) || (this.client.logger.error(ie3, "Signature verification failed"), Se2(Nt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe3 } = ie3, Pe3 = pe(qe3.resources), Ye3 = [dr(qe3.iss)], vt2 = De(qe3.iss);
          if (Pe3) {
            const Ne3 = ds(Pe3), It3 = hs(Pe3);
            Te2.push(...Ne3), Ye3.push(...It3);
          }
          for (const Ne3 of Ye3) ze3.push(`${Ne3}:${vt2}`);
        }
        const se3 = await this.client.core.crypto.generateSharedKey(D2, Q3.publicKey);
        let he3;
        Te2.length > 0 && (he3 = { topic: se3, acknowledged: true, self: { publicKey: D2, metadata: this.client.metadata }, peer: Q3, controller: Q3.publicKey, expiry: Ei(J2), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: g, namespaces: ca([...new Set(Te2)], [...new Set(ze3)]), transportType: r }, await this.client.core.relayer.subscribe(se3, { transportType: r }), await this.client.session.set(se3, he3), g && await this.client.core.pairing.updateMetadata({ topic: g, metadata: Q3.metadata }), he3 = this.client.session.get(se3)), (L2 = this.client.metadata.redirect) != null && L2.linkMode && (Fe3 = Q3.metadata.redirect) != null && Fe3.linkMode && (Qe3 = Q3.metadata.redirect) != null && Qe3.universal && t && (this.client.core.addLinkModeSupportedApp(Q3.metadata.redirect.universal), this.client.session.update(se3, { transportType: Q.link_mode })), je2({ auths: He3, session: he3 });
      };
      this.events.once(le3, pe3), this.events.once(Re2, ve3);
      let Ie3;
      try {
        if (i2) {
          const x2 = formatJsonRpcRequest("wc_sessionAuthenticate", K3, te3);
          this.client.core.history.set(g, x2);
          const L2 = await this.client.core.crypto.encode("", x2, { type: re2, encoding: xe });
          Ie3 = Xc(t, g, L2);
        } else await Promise.all([this.sendRequest({ topic: g, method: "wc_sessionAuthenticate", params: K3, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: te3 }), this.sendRequest({ topic: g, method: "wc_sessionPropose", params: q3, expiry: N.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q3.id })]);
      } catch (x2) {
        throw this.events.off(le3, pe3), this.events.off(Re2, ve3), x2;
      }
      return await this.setProposal(q3.id, q3), await this.setAuthRequest(te3, { request: b(v({}, K3), { verifyContext: {} }), pairingTopic: g, transportType: r }), { uri: Ie3 ?? A2, response: Rt3 };
    }), c(this, "approveSessionAuthenticate", async (e) => {
      const { id: t, auths: s } = e, i2 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [ir.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (f2) {
        throw i2.setError(sr.no_internet_connection), f2;
      }
      const r = this.getPendingAuthRequest(t);
      if (!r) throw i2.setError(sr.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const o2 = r.transportType || Q.relay;
      o2 === Q.relay && await this.confirmOnlineStateOrThrow();
      const a = r.requester.publicKey, l3 = await this.client.core.crypto.generateKeyPair(), p = Pc(a), h2 = { type: Ft, receiverPublicKey: a, senderPublicKey: l3 }, u2 = [], d2 = [];
      for (const f2 of s) {
        if (!await is({ cacao: f2, projectId: this.client.core.projectId })) {
          i2.setError(sr.invalid_cacao);
          const I2 = Nt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: p, error: I2, encodeOpts: h2 }), new Error(I2.message);
        }
        i2.addTrace(ir.cacaos_verified);
        const { p: _ } = f2, g = pe(_.resources), A2 = [dr(_.iss)], D2 = De(_.iss);
        if (g) {
          const I2 = ds(g), T2 = hs(g);
          u2.push(...I2), A2.push(...T2);
        }
        for (const I2 of A2) d2.push(`${I2}:${D2}`);
      }
      const w = await this.client.core.crypto.generateSharedKey(l3, a);
      i2.addTrace(ir.create_authenticated_session_topic);
      let m;
      if (u2?.length > 0) {
        m = { topic: w, acknowledged: true, self: { publicKey: l3, metadata: this.client.metadata }, peer: { publicKey: a, metadata: r.requester.metadata }, controller: a, expiry: Ei(J2), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r.pairingTopic, namespaces: ca([...new Set(u2)], [...new Set(d2)]), transportType: o2 }, i2.addTrace(ir.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w, { transportType: o2 });
        } catch (f2) {
          throw i2.setError(sr.subscribe_authenticated_session_topic_failure), f2;
        }
        i2.addTrace(ir.subscribe_authenticated_session_topic_success), await this.client.session.set(w, m), i2.addTrace(ir.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r.pairingTopic, metadata: r.requester.metadata });
      }
      i2.addTrace(ir.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p, id: t, result: { cacaos: s, responder: { publicKey: l3, metadata: this.client.metadata } }, encodeOpts: h2, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r.requester.metadata, o2) });
      } catch (f2) {
        throw i2.setError(sr.authenticated_session_approve_publish_failure), f2;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i2.eventId }), { session: m };
    }), c(this, "rejectSessionAuthenticate", async (e) => {
      this.isInitialized();
      const { id: t, reason: s } = e, i2 = this.getPendingAuthRequest(t);
      if (!i2) throw new Error(`Could not find pending auth request with id ${t}`);
      i2.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const r = i2.requester.publicKey, o2 = await this.client.core.crypto.generateKeyPair(), a = Pc(r), l3 = { type: Ft, receiverPublicKey: r, senderPublicKey: o2 };
      await this.sendError({ id: t, topic: a, error: s, encodeOpts: l3, rpcOpts: N.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i2.requester.metadata, i2.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, Nt("USER_DISCONNECTED"));
    }), c(this, "formatAuthMessage", (e) => {
      this.isInitialized();
      const { request: t, iss: s } = e;
      return hr(t, s);
    }), c(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }), c(this, "cleanupDuplicatePairings", async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i2) => {
          var r, o2;
          return ((r = i2.peerMetadata) == null ? void 0 : r.url) && ((o2 = i2.peerMetadata) == null ? void 0 : o2.url) === e.peer.metadata.url && i2.topic && i2.topic !== t.topic;
        });
        if (s.length === 0) return;
        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i2) => this.client.core.pairing.disconnect({ topic: i2.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c(this, "deleteSession", async (e) => {
      var t;
      const { topic: s, expirerHasDeleted: i2 = false, emitEvent: r = true, id: o2 = 0 } = e, { self: a } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, Nt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(a.publicKey) && await this.client.core.crypto.deleteKeyPair(a.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i2 || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Me2).catch((l3) => this.client.logger.warn(l3)), this.getPendingSessionRequests().forEach((l3) => {
        l3.topic === s && this.deletePendingSessionRequest(l3.id, Nt("USER_DISCONNECTED"));
      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $.idle), r && this.client.events.emit("session_delete", { id: o2, topic: s });
    }), c(this, "deleteProposal", async (e, t) => {
      if (t) try {
        const s = this.client.proposal.get(e), i2 = this.client.core.eventClient.getEvent({ topic: s.pairingTopic });
        i2?.setError(tr.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, Nt("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }), c(this, "deletePendingSessionRequest", async (e, t, s = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i2) => i2.id !== e), s && (this.sessionRequestQueue.state = $.idle, this.client.events.emit("session_request_expire", { id: e }));
    }), c(this, "deletePendingAuthRequest", async (e, t, s = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }), c(this, "setExpiry", async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }), c(this, "setProposal", async (e, t) => {
      this.client.core.expirer.set(e, Ei(N.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }), c(this, "setAuthRequest", async (e, t) => {
      const { request: s, pairingTopic: i2, transportType: r = Q.relay } = t;
      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: e, pairingTopic: i2, verifyContext: s.verifyContext, transportType: r });
    }), c(this, "setPendingSessionRequest", async (e) => {
      const { id: t, topic: s, params: i2, verifyContext: r } = e, o2 = i2.request.expiryTimestamp || Ei(N.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, o2), await this.client.pendingRequest.set(t, { id: t, topic: s, params: i2, verifyContext: r });
    }), c(this, "sendRequest", async (e) => {
      const { topic: t, method: s, params: i2, expiry: r, relayRpcId: o2, clientRpcId: a, throwOnFailedPublish: l3, appLink: p, tvf: h2 } = e, u2 = formatJsonRpcRequest(s, i2, a);
      let d2;
      const w = !!p;
      try {
        const _ = w ? xe : qt;
        d2 = await this.client.core.crypto.encode(t, u2, { encoding: _ });
      } catch (_) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _;
      }
      let m;
      if (gt2.includes(s)) {
        const _ = kc(JSON.stringify(u2)), g = kc(d2);
        m = await this.client.core.verify.register({ id: g, decryptedId: _ });
      }
      const f2 = N[s].req;
      if (f2.attestation = m, r && (f2.ttl = r), o2 && (f2.id = o2), this.client.core.history.set(t, u2), w) {
        const _ = Xc(p, t, d2);
        await global.Linking.openURL(_, this.client.name);
      } else {
        const _ = N[s].req;
        r && (_.ttl = r), o2 && (_.id = o2), _.tvf = b(v({}, h2), { correlationId: u2.id }), l3 ? (_.internal = b(v({}, _.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d2, _)) : this.client.core.relayer.publish(t, d2, _).catch((g) => this.client.logger.error(g));
      }
      return u2.id;
    }), c(this, "sendResult", async (e) => {
      const { id: t, topic: s, result: i2, throwOnFailedPublish: r, encodeOpts: o2, appLink: a } = e, l3 = formatJsonRpcResult(t, i2);
      let p;
      const h2 = a && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w = h2 ? xe : qt;
        p = await this.client.core.crypto.encode(s, l3, b(v({}, o2 || {}), { encoding: w }));
      } catch (w) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), w;
      }
      let u2, d2;
      try {
        u2 = await this.client.core.history.get(s, t);
        const w = u2.request;
        try {
          this.shouldSetTVF(w.method, w.params) && (d2 = this.getTVFParams(t, w.params, i2));
        } catch (m) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", m);
        }
      } catch (w) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), w;
      }
      if (h2) {
        const w = Xc(a, s, p);
        await global.Linking.openURL(w, this.client.name);
      } else {
        const w = u2.request.method, m = N[w].res;
        m.tvf = b(v({}, d2), { correlationId: t }), r ? (m.internal = b(v({}, m.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, p, m)) : this.client.core.relayer.publish(s, p, m).catch((f2) => this.client.logger.error(f2));
      }
      await this.client.core.history.resolve(l3);
    }), c(this, "sendError", async (e) => {
      const { id: t, topic: s, error: i2, encodeOpts: r, rpcOpts: o2, appLink: a } = e, l3 = formatJsonRpcError(t, i2);
      let p;
      const h2 = a && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d2 = h2 ? xe : qt;
        p = await this.client.core.crypto.encode(s, l3, b(v({}, r || {}), { encoding: d2 }));
      } catch (d2) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d2;
      }
      let u2;
      try {
        u2 = await this.client.core.history.get(s, t);
      } catch (d2) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d2;
      }
      if (h2) {
        const d2 = Xc(a, s, p);
        await global.Linking.openURL(d2, this.client.name);
      } else {
        const d2 = u2.request.method, w = o2 || N[d2].res;
        this.client.core.relayer.publish(s, p, w);
      }
      await this.client.core.history.resolve(l3);
    }), c(this, "cleanup", async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s) => {
        let i2 = false;
        vi(s.expiry) && (i2 = true), this.client.core.crypto.keychain.has(s.topic) || (i2 = true), i2 && e.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        vi(s.expiryTimestamp) && t.push(s.id);
      }), await Promise.all([...e.map((s) => this.deleteSession({ topic: s })), ...t.map((s) => this.deleteProposal(s))]);
    }), c(this, "onProviderMessageEvent", async (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);
    }), c(this, "onRelayEventRequest", async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }), c(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = $.idle;
    }), c(this, "processRequest", async (e) => {
      const { topic: t, payload: s, attestation: i2, transportType: r, encryptedId: o2 } = e, a = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a })) switch (a) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s, attestation: i2, encryptedId: o2 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s, attestation: i2, encryptedId: o2, transportType: r });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s, attestation: i2, encryptedId: o2, transportType: r });
        default:
          return this.client.logger.info(`Unsupported request method ${a}`);
      }
    }), c(this, "onRelayEventResponse", async (e) => {
      const { topic: t, payload: s, transportType: i2 } = e, r = (await this.client.core.history.get(t, s.id)).request.method;
      switch (r) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s, i2);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s);
        default:
          return this.client.logger.info(`Unsupported response method ${r}`);
      }
    }), c(this, "onRelayEventUnknownPayload", (e) => {
      const { topic: t } = e, { message: s } = ht("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), c(this, "shouldIgnorePairingRequest", (e) => {
      const { topic: t, requestMethod: s } = e, i2 = this.expectedPairingMethodMap.get(t);
      return !i2 || i2.includes(s) ? false : !!(i2.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c(this, "onSessionProposeRequest", async (e) => {
      const { topic: t, payload: s, attestation: i2, encryptedId: r } = e, { params: o2, id: a } = s;
      try {
        const l3 = this.client.core.eventClient.getEvent({ topic: t });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l3?.setError(Y.proposal_listener_not_found)), this.isValidConnect(v({}, s.params));
        const p = o2.expiryTimestamp || Ei(N.wc_sessionPropose.req.ttl), h2 = v({ id: a, pairingTopic: t, expiryTimestamp: p }, o2);
        await this.setProposal(a, h2);
        const u2 = await this.getVerifyContext({ attestationId: i2, hash: kc(JSON.stringify(s)), encryptedId: r, metadata: h2.proposer.metadata });
        l3?.addTrace(G.emit_session_proposal), this.client.events.emit("session_proposal", { id: a, params: h2, verifyContext: u2 });
      } catch (l3) {
        await this.sendError({ id: a, topic: t, error: l3, rpcOpts: N.wc_sessionPropose.autoReject }), this.client.logger.error(l3);
      }
    }), c(this, "onSessionProposeResponse", async (e, t, s) => {
      const { id: i2 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r });
        const o2 = this.client.proposal.get(i2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o2 });
        const a = o2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a });
        const l3 = r.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l3 });
        const p = await this.client.core.crypto.generateSharedKey(a, l3);
        this.pendingSessions.set(i2, { sessionTopic: p, pairingTopic: e, proposalId: i2, publicKey: a });
        const h2 = await this.client.core.relayer.subscribe(p, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h2 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i2, Nt("USER_DISCONNECTED"));
        const r = xi("session_connect", i2);
        if (this.events.listenerCount(r) === 0) throw new Error(`emitting ${r} without any listeners, 954`);
        this.events.emit(r, { error: t.error });
      }
    }), c(this, "onSessionSettleRequest", async (e, t) => {
      const { id: s, params: i2 } = t;
      try {
        this.isValidSessionSettleRequest(i2);
        const { relay: r, controller: o2, expiry: a, namespaces: l3, sessionProperties: p, scopedProperties: h2, sessionConfig: u2 } = t.params, d2 = [...this.pendingSessions.values()].find((f2) => f2.sessionTopic === e);
        if (!d2) return this.client.logger.error(`Pending session not found for topic ${e}`);
        const w = this.client.proposal.get(d2.proposalId), m = b(v(v(v({ topic: e, relay: r, expiry: a, namespaces: l3, acknowledged: true, pairingTopic: d2.pairingTopic, requiredNamespaces: w.requiredNamespaces, optionalNamespaces: w.optionalNamespaces, controller: o2.publicKey, self: { publicKey: d2.publicKey, metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, p && { sessionProperties: p }), h2 && { scopedProperties: h2 }), u2 && { sessionConfig: u2 }), { transportType: Q.relay });
        await this.client.session.set(m.topic, m), await this.setExpiry(m.topic, m.expiry), await this.client.core.pairing.updateMetadata({ topic: d2.pairingTopic, metadata: m.peer.metadata }), this.client.events.emit("session_connect", { session: m }), this.events.emit(xi("session_connect", d2.proposalId), { session: m }), this.pendingSessions.delete(d2.proposalId), this.deleteProposal(d2.proposalId, false), this.cleanupDuplicatePairings(m), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r) {
        await this.sendError({ id: s, topic: e, error: r }), this.client.logger.error(r);
      }
    }), c(this, "onSessionSettleResponse", async (e, t) => {
      const { id: s } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(xi("session_approve", s), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, Nt("USER_DISCONNECTED")), this.events.emit(xi("session_approve", s), { error: t.error }));
    }), c(this, "onSessionUpdateRequest", async (e, t) => {
      const { params: s, id: i2 } = t;
      try {
        const r = `${e}_session_update`, o2 = Ra.get(r);
        if (o2 && this.isRequestOutOfSync(o2, i2)) {
          this.client.logger.warn(`Discarding out of sync request - ${i2}`), this.sendError({ id: i2, topic: e, error: Nt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(v({ topic: e }, s));
        try {
          Ra.set(r, i2), await this.client.session.update(e, { namespaces: s.namespaces }), await this.sendResult({ id: i2, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a) {
          throw Ra.delete(r), a;
        }
        this.client.events.emit("session_update", { id: i2, topic: e, params: s });
      } catch (r) {
        await this.sendError({ id: i2, topic: e, error: r }), this.client.logger.error(r);
      }
    }), c(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c(this, "onSessionUpdateResponse", (e, t) => {
      const { id: s } = t, i2 = xi("session_update", s);
      if (this.events.listenerCount(i2) === 0) throw new Error(`emitting ${i2} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_update", s), {}) : isJsonRpcError(t) && this.events.emit(xi("session_update", s), { error: t.error });
    }), c(this, "onSessionExtendRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, Ei(J2)), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s, topic: e });
      } catch (i2) {
        await this.sendError({ id: s, topic: e, error: i2 }), this.client.logger.error(i2);
      }
    }), c(this, "onSessionExtendResponse", (e, t) => {
      const { id: s } = t, i2 = xi("session_extend", s);
      if (this.events.listenerCount(i2) === 0) throw new Error(`emitting ${i2} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_extend", s), {}) : isJsonRpcError(t) && this.events.emit(xi("session_extend", s), { error: t.error });
    }), c(this, "onSessionPingRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s, topic: e });
      } catch (i2) {
        await this.sendError({ id: s, topic: e, error: i2 }), this.client.logger.error(i2);
      }
    }), c(this, "onSessionPingResponse", (e, t) => {
      const { id: s } = t, i2 = xi("session_ping", s);
      setTimeout(() => {
        if (this.events.listenerCount(i2) === 0) throw new Error(`emitting ${i2} without any listeners 2176`);
        isJsonRpcResult(t) ? this.events.emit(xi("session_ping", s), {}) : isJsonRpcError(t) && this.events.emit(xi("session_ping", s), { error: t.error });
      }, 500);
    }), c(this, "onSessionDeleteRequest", async (e, t) => {
      const { id: s } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i2) => {
          this.client.core.relayer.once(C.publish, async () => {
            i2(await this.deleteSession({ topic: e, id: s }));
          });
        }), this.sendResult({ id: s, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: Nt("USER_DISCONNECTED") })]).catch((i2) => this.client.logger.error(i2));
      } catch (i2) {
        this.client.logger.error(i2);
      }
    }), c(this, "onSessionRequest", async (e) => {
      var t, s, i2;
      const { topic: r, payload: o2, attestation: a, encryptedId: l3, transportType: p } = e, { id: h2, params: u2 } = o2;
      try {
        await this.isValidRequest(v({ topic: r }, u2));
        const d2 = this.client.session.get(r), w = await this.getVerifyContext({ attestationId: a, hash: kc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u2, h2))), encryptedId: l3, metadata: d2.peer.metadata, transportType: p }), m = { id: h2, topic: r, params: u2, verifyContext: w };
        await this.setPendingSessionRequest(m), p === Q.link_mode && (t = d2.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d2.peer.metadata.redirect) == null ? void 0 : s.universal), (i2 = this.client.signConfig) != null && i2.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());
      } catch (d2) {
        await this.sendError({ id: h2, topic: r, error: d2 }), this.client.logger.error(d2);
      }
    }), c(this, "onSessionRequestResponse", (e, t) => {
      const { id: s } = t, i2 = xi("session_request", s);
      if (this.events.listenerCount(i2) === 0) throw new Error(`emitting ${i2} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s), { error: t.error });
    }), c(this, "onSessionEventRequest", async (e, t) => {
      const { id: s, params: i2 } = t;
      try {
        const r = `${e}_session_event_${i2.event.name}`, o2 = Ra.get(r);
        if (o2 && this.isRequestOutOfSync(o2, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(v({ topic: e }, i2)), this.client.events.emit("session_event", { id: s, topic: e, params: i2 }), Ra.set(r, s);
      } catch (r) {
        await this.sendError({ id: s, topic: e, error: r }), this.client.logger.error(r);
      }
    }), c(this, "onSessionAuthenticateResponse", (e, t) => {
      const { id: s } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(xi("session_request", s), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s), { error: t.error });
    }), c(this, "onSessionAuthenticateRequest", async (e) => {
      var t;
      const { topic: s, payload: i2, attestation: r, encryptedId: o2, transportType: a } = e;
      try {
        const { requester: l3, authPayload: p, expiryTimestamp: h2 } = i2.params, u2 = await this.getVerifyContext({ attestationId: r, hash: kc(JSON.stringify(i2)), encryptedId: o2, metadata: l3.metadata, transportType: a }), d2 = { requester: l3, pairingTopic: s, id: i2.id, authPayload: p, verifyContext: u2, expiryTimestamp: h2 };
        await this.setAuthRequest(i2.id, { request: d2, pairingTopic: s, transportType: a }), a === Q.link_mode && (t = l3.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l3.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: i2.params, id: i2.id, verifyContext: u2 });
      } catch (l3) {
        this.client.logger.error(l3);
        const p = i2.params.requester.publicKey, h2 = await this.client.core.crypto.generateKeyPair(), u2 = this.getAppLinkIfEnabled(i2.params.requester.metadata, a), d2 = { type: Ft, receiverPublicKey: p, senderPublicKey: h2 };
        await this.sendError({ id: i2.id, topic: s, error: l3, encodeOpts: d2, rpcOpts: N.wc_sessionAuthenticate.autoReject, appLink: u2 });
      }
    }), c(this, "addSessionRequestToSessionRequestQueue", (e) => {
      this.sessionRequestQueue.queue.push(e);
    }), c(this, "cleanupAfterResponse", (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $.idle, this.processSessionRequestQueue();
      }, (0, import_time2.toMiliseconds)(this.requestQueueDelay));
    }), c(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((i2) => i2.topic === e && i2.request.method === "wc_sessionRequest").forEach((i2) => {
        const r = i2.request.id, o2 = xi("session_request", r);
        if (this.events.listenerCount(o2) === 0) throw new Error(`emitting ${o2} without any listeners`);
        this.events.emit(xi("session_request", i2.request.id), { error: t });
      });
    }), c(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c(this, "emitSessionRequest", (e) => {
      this.client.events.emit("session_request", e);
    }), c(this, "onPairingCreated", (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s) => s.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", b(v({}, t), { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties, scopedProperties: t.scopedProperties }), t.id) });
    }), c(this, "isValidConnect", async (e) => {
      if (!ma(e)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(l3);
      }
      const { pairingTopic: t, requiredNamespaces: s, optionalNamespaces: i2, sessionProperties: r, scopedProperties: o2, relays: a } = e;
      if (Et(t) || await this.isValidPairingTopic(t), !ga(a, true)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(l3);
      }
      if (!Et(s) && Oe(s) !== 0) {
        const l3 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l3) : this.client.logger.warn(l3), this.validateNamespaces(s, "requiredNamespaces");
      }
      if (!Et(i2) && Oe(i2) !== 0 && this.validateNamespaces(i2, "optionalNamespaces"), Et(r) || this.validateSessionProps(r, "sessionProperties"), !Et(o2)) {
        this.validateSessionProps(o2, "scopedProperties");
        const l3 = Object.keys(s || {}).concat(Object.keys(i2 || {}));
        if (!Object.keys(o2).every((p) => l3.includes(p))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o2)}, required/optional namespaces: ${JSON.stringify(l3)}`);
      }
    }), c(this, "validateNamespaces", (e, t) => {
      const s = pa(e, "connect()", t);
      if (s) throw new Error(s.message);
    }), c(this, "isValidApprove", async (e) => {
      if (!ma(e)) throw new Error(ht("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s, relayProtocol: i2, sessionProperties: r, scopedProperties: o2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const a = this.client.proposal.get(t), l3 = Bo(s, "approve()");
      if (l3) throw new Error(l3.message);
      const p = No(a.requiredNamespaces, s, "approve()");
      if (p) throw new Error(p.message);
      if (!nt(i2, true)) {
        const { message: h2 } = ht("MISSING_OR_INVALID", `approve() relayProtocol: ${i2}`);
        throw new Error(h2);
      }
      if (Et(r) || this.validateSessionProps(r, "sessionProperties"), !Et(o2)) {
        this.validateSessionProps(o2, "scopedProperties");
        const h2 = new Set(Object.keys(s));
        if (!Object.keys(o2).every((u2) => h2.has(u2))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o2)}, approved namespaces: ${Array.from(h2).join(", ")}`);
      }
    }), c(this, "isValidReject", async (e) => {
      if (!ma(e)) {
        const { message: i2 } = ht("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i2);
      }
      const { id: t, reason: s } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !wa(s)) {
        const { message: i2 } = ht("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(i2);
      }
    }), c(this, "isValidSessionSettleRequest", (e) => {
      if (!ma(e)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l3);
      }
      const { relay: t, controller: s, namespaces: i2, expiry: r } = e;
      if (!Io(t)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l3);
      }
      const o2 = ha(s, "onSessionSettleRequest()");
      if (o2) throw new Error(o2.message);
      const a = Bo(i2, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      if (vi(r)) {
        const { message: l3 } = ht("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l3);
      }
    }), c(this, "isValidUpdate", async (e) => {
      if (!ma(e)) {
        const { message: a } = ht("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a);
      }
      const { topic: t, namespaces: s } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i2 = this.client.session.get(t), r = Bo(s, "update()");
      if (r) throw new Error(r.message);
      const o2 = No(i2.requiredNamespaces, s, "update()");
      if (o2) throw new Error(o2.message);
    }), c(this, "isValidExtend", async (e) => {
      if (!ma(e)) {
        const { message: s } = ht("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }), c(this, "isValidRequest", async (e) => {
      if (!ma(e)) {
        const { message: a } = ht("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a);
      }
      const { topic: t, request: s, chainId: i2, expiry: r } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: o2 } = this.client.session.get(t);
      if (!xa(o2, i2)) {
        const { message: a } = ht("MISSING_OR_INVALID", `request() chainId: ${i2}`);
        throw new Error(a);
      }
      if (!ba(s)) {
        const { message: a } = ht("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(a);
      }
      if (!Sa(o2, i2, s.method)) {
        const { message: a } = ht("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(a);
      }
      if (r && !Ia(r, _e2)) {
        const { message: a } = ht("MISSING_OR_INVALID", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${_e2.min} and ${_e2.max}`);
        throw new Error(a);
      }
    }), c(this, "isValidRespond", async (e) => {
      var t;
      if (!ma(e)) {
        const { message: r } = ht("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r);
      }
      const { topic: s, response: i2 } = e;
      try {
        await this.isValidSessionTopic(s);
      } catch (r) {
        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r;
      }
      if (!Ea(i2)) {
        const { message: r } = ht("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i2)}`);
        throw new Error(r);
      }
    }), c(this, "isValidPing", async (e) => {
      if (!ma(e)) {
        const { message: s } = ht("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c(this, "isValidEmit", async (e) => {
      if (!ma(e)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o2);
      }
      const { topic: t, event: s, chainId: i2 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r } = this.client.session.get(t);
      if (!xa(r, i2)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() chainId: ${i2}`);
        throw new Error(o2);
      }
      if (!va(s)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o2);
      }
      if (!Oa(r, i2, s.name)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(o2);
      }
    }), c(this, "isValidDisconnect", async (e) => {
      if (!ma(e)) {
        const { message: s } = ht("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c(this, "isValidAuthenticate", (e) => {
      const { chains: t, uri: s, domain: i2, nonce: r } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!nt(s, false)) throw new Error("uri is required parameter");
      if (!nt(i2, false)) throw new Error("domain is required parameter");
      if (!nt(r, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a) => Ne(a).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o2 } = Ne(t[0]);
      if (o2 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c(this, "getVerifyContext", async (e) => {
      const { attestationId: t, hash: s, encryptedId: i2, metadata: r, transportType: o2 } = e, a = { verified: { verifyUrl: r.verifyUrl || ue, validation: "UNKNOWN", origin: r.url || "" } };
      try {
        if (o2 === Q.link_mode) {
          const p = this.getAppLinkIfEnabled(r, o2);
          return a.verified.validation = p && new URL(p).origin === new URL(r.url).origin ? "VALID" : "INVALID", a;
        }
        const l3 = await this.client.core.verify.resolve({ attestationId: t, hash: s, encryptedId: i2, verifyUrl: r.verifyUrl });
        l3 && (a.verified.origin = l3.origin, a.verified.isScam = l3.isScam, a.verified.validation = l3.origin === new URL(r.url).origin ? "VALID" : "INVALID");
      } catch (l3) {
        this.client.logger.warn(l3);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`), a;
    }), c(this, "validateSessionProps", (e, t) => {
      Object.values(e).forEach((s, i2) => {
        if (s == null) {
          const { message: r } = ht("MISSING_OR_INVALID", `${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i2]}`);
          throw new Error(r);
        }
      });
    }), c(this, "getPendingAuthRequest", (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }), c(this, "addToRecentlyDeleted", (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const i2 = this.recentlyDeletedLimit / 2;
        for (const r of this.recentlyDeletedMap.keys()) {
          if (s++ >= i2) break;
          this.recentlyDeletedMap.delete(r);
        }
      }
    }), c(this, "checkRecentlyDeleted", (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s } = ht("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s);
      }
    }), c(this, "isLinkModeEnabled", (e, t) => {
      var s, i2, r, o2, a, l3, p, h2, u2;
      return !e || t !== Q.link_mode ? false : ((i2 = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i2.linkMode) === true && ((o2 = (r = this.client.metadata) == null ? void 0 : r.redirect) == null ? void 0 : o2.universal) !== void 0 && ((l3 = (a = this.client.metadata) == null ? void 0 : a.redirect) == null ? void 0 : l3.universal) !== "" && ((p = e?.redirect) == null ? void 0 : p.universal) !== void 0 && ((h2 = e?.redirect) == null ? void 0 : h2.universal) !== "" && ((u2 = e?.redirect) == null ? void 0 : u2.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c(this, "getAppLinkIfEnabled", (e, t) => {
      var s;
      return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;
    }), c(this, "handleLinkModeMessage", ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = Ai(e, "topic") || "", s = decodeURIComponent(Ai(e, "wc_ev") || ""), i2 = this.client.session.keys.includes(t);
      i2 && this.client.session.update(t, { transportType: Q.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s, sessionExists: i2 });
    }), c(this, "registerLinkModeListeners", async () => {
      var e;
      if (Ii() || pt() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await t.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), c(this, "shouldSetTVF", (e, t) => {
      if (!t || e !== "wc_sessionRequest") return false;
      const { request: s } = t;
      return Object.keys(Ke2).includes(s.method);
    }), c(this, "getTVFParams", (e, t, s) => {
      var i2, r;
      try {
        const o2 = t.request.method, a = this.extractTxHashesFromResult(o2, s);
        return b(v({ correlationId: e, rpcMethods: [o2], chainId: t.chainId }, this.isValidContractData(t.request.params) && { contractAddresses: [(r = (i2 = t.request.params) == null ? void 0 : i2[0]) == null ? void 0 : r.to] }), { txHashes: a });
      } catch (o2) {
        this.client.logger.warn("Error getting TVF params", o2);
      }
      return {};
    }), c(this, "isValidContractData", (e) => {
      var t;
      if (!e) return false;
      try {
        const s = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);
        if (!s.startsWith("0x")) return false;
        const i2 = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(i2) ? i2.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c(this, "extractTxHashesFromResult", (e, t) => {
      try {
        const s = Ke2[e];
        if (typeof t == "string") return [t];
        const i2 = t[s.key];
        if (se(i2)) return e === "solana_signAllTransactions" ? i2.map((r) => Ji(r)) : i2;
        if (typeof i2 == "string") return [i2];
      } catch (s) {
        this.client.logger.warn("Error extracting tx hashes from result", s);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const n2 = this.client.session.keys, e = this.client.core.relayer.messages.getWithoutAck(n2);
      for (const [t, s] of Object.entries(e)) for (const i2 of s) try {
        await this.onProviderMessageEvent({ topic: t, message: i2, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i2}`);
      }
    } catch (n2) {
      this.client.logger.warn("processPendingMessageEvents failed", n2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n2 } = ht("NOT_INITIALIZED", this.name);
      throw new Error(n2);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C.message, (n2) => {
      this.onProviderMessageEvent(n2);
    });
  }
  async onRelayMessage(n2) {
    const { topic: e, message: t, attestation: s, transportType: i2 } = n2, { publicKey: r } = this.client.auth.authKeys.keys.includes(ce2) ? this.client.auth.authKeys.get(ce2) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const o2 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r, encoding: i2 === Q.link_mode ? xe : qt });
      isJsonRpcRequest(o2) ? (this.client.core.history.set(e, o2), await this.onRelayEventRequest({ topic: e, payload: o2, attestation: s, transportType: i2, encryptedId: kc(t) })) : isJsonRpcResponse(o2) ? (await this.client.core.history.resolve(o2), await this.onRelayEventResponse({ topic: e, payload: o2, transportType: i2 }), this.client.core.history.delete(e, o2.id)) : await this.onRelayEventUnknownPayload({ topic: e, payload: o2, transportType: i2 }), await this.client.core.relayer.messages.ack(e, t);
    } catch (o2) {
      this.client.logger.error(o2);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M.expired, async (n2) => {
      const { topic: e, id: t } = bi(n2.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, ht("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, ht("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(re.create, (n2) => this.onPairingCreated(n2)), this.client.core.pairing.events.on(re.delete, (n2) => {
      this.addToRecentlyDeleted(n2.topic, "pairing");
    });
  }
  isValidPairingTopic(n2) {
    if (!nt(n2, false)) {
      const { message: e } = ht("MISSING_OR_INVALID", `pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n2)) {
      const { message: e } = ht("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.core.pairing.pairings.get(n2).expiry)) {
      const { message: e } = ht("EXPIRED", `pairing topic: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n2) {
    if (!nt(n2, false)) {
      const { message: e } = ht("MISSING_OR_INVALID", `session topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(n2), !this.client.session.keys.includes(n2)) {
      const { message: e } = ht("NO_MATCHING_KEY", `session topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.session.get(n2).expiry)) {
      await this.deleteSession({ topic: n2 });
      const { message: e } = ht("EXPIRED", `session topic: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(n2)) {
      const { message: e } = ht("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n2}`);
      throw await this.deleteSession({ topic: n2 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n2) {
    if (this.checkRecentlyDeleted(n2), this.client.session.keys.includes(n2)) await this.isValidSessionTopic(n2);
    else if (this.client.core.pairing.pairings.keys.includes(n2)) this.isValidPairingTopic(n2);
    else if (nt(n2, false)) {
      const { message: e } = ht("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    } else {
      const { message: e } = ht("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n2) {
    if (!ya(n2)) {
      const { message: e } = ht("MISSING_OR_INVALID", `proposal id should be a number: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n2)) {
      const { message: e } = ht("NO_MATCHING_KEY", `proposal id doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.proposal.get(n2).expiryTimestamp)) {
      await this.deleteProposal(n2);
      const { message: e } = ht("EXPIRED", `proposal id: ${n2}`);
      throw new Error(e);
    }
  }
};
var Os2 = class extends zi {
  constructor(n2, e) {
    super(n2, e, pt2, we2), this.core = n2, this.logger = e;
  }
};
var St2 = class extends zi {
  constructor(n2, e) {
    super(n2, e, ht2, we2), this.core = n2, this.logger = e;
  }
};
var bs2 = class extends zi {
  constructor(n2, e) {
    super(n2, e, ut2, we2, (t) => t.id), this.core = n2, this.logger = e;
  }
};
var As2 = class extends zi {
  constructor(n2, e) {
    super(n2, e, mt2, ae2, () => ce2), this.core = n2, this.logger = e;
  }
};
var xs2 = class extends zi {
  constructor(n2, e) {
    super(n2, e, _t2, ae2), this.core = n2, this.logger = e;
  }
};
var Cs2 = class extends zi {
  constructor(n2, e) {
    super(n2, e, Et2, ae2, (t) => t.id), this.core = n2, this.logger = e;
  }
};
var Vs = Object.defineProperty;
var Ds2 = (S2, n2, e) => n2 in S2 ? Vs(S2, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S2[n2] = e;
var Ge2 = (S2, n2, e) => Ds2(S2, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ls2 = class {
  constructor(n2, e) {
    this.core = n2, this.logger = e, Ge2(this, "authKeys"), Ge2(this, "pairingTopics"), Ge2(this, "requests"), this.authKeys = new As2(this.core, this.logger), this.pairingTopics = new xs2(this.core, this.logger), this.requests = new Cs2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var ks = Object.defineProperty;
var Ms2 = (S2, n2, e) => n2 in S2 ? ks(S2, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S2[n2] = e;
var E2 = (S2, n2, e) => Ms2(S2, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ee2 = class _Ee extends J {
  constructor(n2) {
    super(n2), E2(this, "protocol", De2), E2(this, "version", Le), E2(this, "name", me2.name), E2(this, "metadata"), E2(this, "core"), E2(this, "logger"), E2(this, "events", new import_events3.EventEmitter()), E2(this, "engine"), E2(this, "session"), E2(this, "proposal"), E2(this, "pendingRequest"), E2(this, "auth"), E2(this, "signConfig"), E2(this, "on", (t, s) => this.events.on(t, s)), E2(this, "once", (t, s) => this.events.once(t, s)), E2(this, "off", (t, s) => this.events.off(t, s)), E2(this, "removeListener", (t, s) => this.events.removeListener(t, s)), E2(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), E2(this, "connect", async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "pair", async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "approve", async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "reject", async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "update", async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "extend", async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "request", async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "respond", async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "ping", async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "emit", async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "disconnect", async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "find", (t) => {
      try {
        return this.engine.find(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }), E2(this, "authenticate", async (t, s) => {
      try {
        return await this.engine.authenticate(t, s);
      } catch (i2) {
        throw this.logger.error(i2.message), i2;
      }
    }), E2(this, "formatAuthMessage", (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "approveSessionAuthenticate", async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), E2(this, "rejectSessionAuthenticate", async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = n2?.name || me2.name, this.metadata = oi(n2?.metadata), this.signConfig = n2?.signConfig;
    const e = typeof n2?.logger < "u" && typeof n2?.logger != "string" ? n2.logger : (0, import_pino.default)(k({ level: n2?.logger || me2.logger }));
    this.core = n2?.core || new Xo(n2), this.logger = E(e, this.name), this.session = new St2(this.core, this.logger), this.proposal = new Os2(this.core, this.logger), this.pendingRequest = new bs2(this.core, this.logger), this.engine = new Ns2(this), this.auth = new Ls2(this.core, this.logger);
  }
  static async init(n2) {
    const e = new _Ee(n2);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND));
    } catch (n2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n2.message), n2;
    }
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events4 = __toESM(require_events());
var et2 = "error";
var St3 = "wss://relay.walletconnect.org";
var Dt2 = "wc";
var qt2 = "universal_provider";
var U3 = `${Dt2}@2:${qt2}:`;
var st = "https://rpc.walletconnect.org/v1/";
var I = "generic";
var jt2 = `${st}bundler`;
var u = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function Rt2() {
}
function k3(s) {
  return s == null || typeof s != "object" && typeof s != "function";
}
function W(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function _t3(s) {
  if (k3(s)) return s;
  if (Array.isArray(s) || W(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  const t = Object.getPrototypeOf(s), e = t.constructor;
  if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);
  if (s instanceof RegExp) {
    const i2 = new e(s);
    return i2.lastIndex = s.lastIndex, i2;
  }
  if (s instanceof DataView) return new e(s.buffer.slice(0));
  if (s instanceof Error) {
    const i2 = new e(s.message);
    return i2.stack = s.stack, i2.name = s.name, i2.cause = s.cause, i2;
  }
  if (typeof File < "u" && s instanceof File) return new e([s], s.name, { type: s.type, lastModified: s.lastModified });
  if (typeof s == "object") {
    const i2 = Object.create(t);
    return Object.assign(i2, s);
  }
  return s;
}
function it2(s) {
  return typeof s == "object" && s !== null;
}
function rt(s) {
  return Object.getOwnPropertySymbols(s).filter((t) => Object.prototype.propertyIsEnumerable.call(s, t));
}
function nt2(s) {
  return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
var Ut = "[object RegExp]";
var at2 = "[object String]";
var ct2 = "[object Number]";
var ot2 = "[object Boolean]";
var ht3 = "[object Arguments]";
var Ft2 = "[object Symbol]";
var Lt2 = "[object Date]";
var Mt2 = "[object Map]";
var xt3 = "[object Set]";
var Bt = "[object Array]";
var Gt = "[object ArrayBuffer]";
var Jt2 = "[object Object]";
var zt = "[object DataView]";
var kt3 = "[object Uint8Array]";
var Wt2 = "[object Uint8ClampedArray]";
var Kt2 = "[object Uint16Array]";
var Vt2 = "[object Uint32Array]";
var Xt2 = "[object Int8Array]";
var Yt2 = "[object Int16Array]";
var Qt2 = "[object Int32Array]";
var Zt = "[object Float32Array]";
var Tt2 = "[object Float64Array]";
function te2(s, t) {
  return $2(s, void 0, s, /* @__PURE__ */ new Map(), t);
}
function $2(s, t, e, i2 = /* @__PURE__ */ new Map(), n2 = void 0) {
  const a = n2?.(s, t, e, i2);
  if (a != null) return a;
  if (k3(s)) return s;
  if (i2.has(s)) return i2.get(s);
  if (Array.isArray(s)) {
    const r = new Array(s.length);
    i2.set(s, r);
    for (let c2 = 0; c2 < s.length; c2++) r[c2] = $2(s[c2], c2, e, i2, n2);
    return Object.hasOwn(s, "index") && (r.index = s.index), Object.hasOwn(s, "input") && (r.input = s.input), r;
  }
  if (s instanceof Date) return new Date(s.getTime());
  if (s instanceof RegExp) {
    const r = new RegExp(s.source, s.flags);
    return r.lastIndex = s.lastIndex, r;
  }
  if (s instanceof Map) {
    const r = /* @__PURE__ */ new Map();
    i2.set(s, r);
    for (const [c2, o2] of s) r.set(c2, $2(o2, c2, e, i2, n2));
    return r;
  }
  if (s instanceof Set) {
    const r = /* @__PURE__ */ new Set();
    i2.set(s, r);
    for (const c2 of s) r.add($2(c2, void 0, e, i2, n2));
    return r;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
  if (W(s)) {
    const r = new (Object.getPrototypeOf(s)).constructor(s.length);
    i2.set(s, r);
    for (let c2 = 0; c2 < s.length; c2++) r[c2] = $2(s[c2], c2, e, i2, n2);
    return r;
  }
  if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
  if (s instanceof DataView) {
    const r = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
    return i2.set(s, r), y2(r, s, e, i2, n2), r;
  }
  if (typeof File < "u" && s instanceof File) {
    const r = new File([s], s.name, { type: s.type });
    return i2.set(s, r), y2(r, s, e, i2, n2), r;
  }
  if (s instanceof Blob) {
    const r = new Blob([s], { type: s.type });
    return i2.set(s, r), y2(r, s, e, i2, n2), r;
  }
  if (s instanceof Error) {
    const r = new s.constructor();
    return i2.set(s, r), r.message = s.message, r.name = s.name, r.stack = s.stack, r.cause = s.cause, y2(r, s, e, i2, n2), r;
  }
  if (typeof s == "object" && ee2(s)) {
    const r = Object.create(Object.getPrototypeOf(s));
    return i2.set(s, r), y2(r, s, e, i2, n2), r;
  }
  return s;
}
function y2(s, t, e = s, i2, n2) {
  const a = [...Object.keys(t), ...rt(t)];
  for (let r = 0; r < a.length; r++) {
    const c2 = a[r], o2 = Object.getOwnPropertyDescriptor(s, c2);
    (o2 == null || o2.writable) && (s[c2] = $2(t[c2], c2, e, i2, n2));
  }
}
function ee2(s) {
  switch (nt2(s)) {
    case ht3:
    case Bt:
    case Gt:
    case zt:
    case ot2:
    case Lt2:
    case Zt:
    case Tt2:
    case Xt2:
    case Yt2:
    case Qt2:
    case Mt2:
    case ct2:
    case Jt2:
    case Ut:
    case xt3:
    case at2:
    case Ft2:
    case kt3:
    case Wt2:
    case Kt2:
    case Vt2:
      return true;
    default:
      return false;
  }
}
function se2(s, t) {
  return te2(s, (e, i2, n2, a) => {
    const r = t?.(e, i2, n2, a);
    if (r != null) return r;
    if (typeof s == "object") switch (Object.prototype.toString.call(s)) {
      case ct2:
      case at2:
      case ot2: {
        const c2 = new s.constructor(s?.valueOf());
        return y2(c2, s), c2;
      }
      case ht3: {
        const c2 = {};
        return y2(c2, s), c2.length = s.length, c2[Symbol.iterator] = s[Symbol.iterator], c2;
      }
      default:
        return;
    }
  });
}
function pt3(s) {
  return se2(s);
}
function dt3(s) {
  return s !== null && typeof s == "object" && nt2(s) === "[object Arguments]";
}
function ie2(s) {
  return W(s);
}
function re3(s) {
  if (typeof s != "object" || s == null) return false;
  if (Object.getPrototypeOf(s) === null) return true;
  if (Object.prototype.toString.call(s) !== "[object Object]") {
    const e = s[Symbol.toStringTag];
    return e == null || !Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)?.writable ? false : s.toString() === `[object ${e}]`;
  }
  let t = s;
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(s) === t;
}
function ne2(s, ...t) {
  const e = t.slice(0, -1), i2 = t[t.length - 1];
  let n2 = s;
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    n2 = F2(n2, r, i2, /* @__PURE__ */ new Map());
  }
  return n2;
}
function F2(s, t, e, i2) {
  if (k3(s) && (s = Object(s)), t == null || typeof t != "object") return s;
  if (i2.has(t)) return _t3(i2.get(t));
  if (i2.set(t, s), Array.isArray(t)) {
    t = t.slice();
    for (let a = 0; a < t.length; a++) t[a] = t[a] ?? void 0;
  }
  const n2 = [...Object.keys(t), ...rt(t)];
  for (let a = 0; a < n2.length; a++) {
    const r = n2[a];
    let c2 = t[r], o2 = s[r];
    if (dt3(c2) && (c2 = { ...c2 }), dt3(o2) && (o2 = { ...o2 }), typeof Buffer < "u" && Buffer.isBuffer(c2) && (c2 = pt3(c2)), Array.isArray(c2)) if (typeof o2 == "object" && o2 != null) {
      const w = [], v2 = Reflect.ownKeys(o2);
      for (let P = 0; P < v2.length; P++) {
        const p = v2[P];
        w[p] = o2[p];
      }
      o2 = w;
    } else o2 = [];
    const m = e(o2, c2, r, s, t, i2);
    m != null ? s[r] = m : Array.isArray(c2) || it2(o2) && it2(c2) ? s[r] = F2(o2, c2, e, i2) : o2 == null && re3(c2) ? s[r] = F2({}, c2, e, i2) : o2 == null && ie2(c2) ? s[r] = pt3(c2) : (o2 === void 0 || c2 !== void 0) && (s[r] = c2);
  }
  return s;
}
function ae3(s, ...t) {
  return ne2(s, ...t, Rt2);
}
var ce3 = Object.defineProperty;
var oe = Object.defineProperties;
var he2 = Object.getOwnPropertyDescriptors;
var ut3 = Object.getOwnPropertySymbols;
var pe2 = Object.prototype.hasOwnProperty;
var de2 = Object.prototype.propertyIsEnumerable;
var lt2 = (s, t, e) => t in s ? ce3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var L = (s, t) => {
  for (var e in t || (t = {})) pe2.call(t, e) && lt2(s, e, t[e]);
  if (ut3) for (var e of ut3(t)) de2.call(t, e) && lt2(s, e, t[e]);
  return s;
};
var ue3 = (s, t) => oe(s, he2(t));
function d(s, t, e) {
  var i2;
  const n2 = Ne(s);
  return ((i2 = t.rpcMap) == null ? void 0 : i2[n2.reference]) || `${st}?chainId=${n2.namespace}:${n2.reference}&projectId=${e}`;
}
function b2(s) {
  return s.includes(":") ? s.split(":")[1] : s;
}
function ft3(s) {
  return s.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function le2(s, t) {
  const e = Object.keys(t.namespaces).filter((n2) => n2.includes(s));
  if (!e.length) return [];
  const i2 = [];
  return e.forEach((n2) => {
    const a = t.namespaces[n2].accounts;
    i2.push(...a);
  }), i2;
}
function M2(s = {}, t = {}) {
  const e = mt3(s), i2 = mt3(t);
  return ae3(e, i2);
}
function mt3(s) {
  var t, e, i2, n2, a;
  const r = {};
  if (!Oe(s)) return r;
  for (const [c2, o2] of Object.entries(s)) {
    const m = yn(c2) ? [c2] : o2.chains, w = o2.methods || [], v2 = o2.events || [], P = o2.rpcMap || {}, p = yo(c2);
    r[p] = ue3(L(L({}, r[p]), o2), { chains: ot(m, (t = r[p]) == null ? void 0 : t.chains), methods: ot(w, (e = r[p]) == null ? void 0 : e.methods), events: ot(v2, (i2 = r[p]) == null ? void 0 : i2.events) }), (Oe(P) || Oe(((n2 = r[p]) == null ? void 0 : n2.rpcMap) || {})) && (r[p].rpcMap = L(L({}, P), (a = r[p]) == null ? void 0 : a.rpcMap));
  }
  return r;
}
function vt(s) {
  return s.includes(":") ? s.split(":")[2] : s;
}
function gt3(s) {
  const t = {};
  for (const [e, i2] of Object.entries(s)) {
    const n2 = i2.methods || [], a = i2.events || [], r = i2.accounts || [], c2 = yn(e) ? [e] : i2.chains ? i2.chains : ft3(i2.accounts);
    t[e] = { chains: c2, methods: n2, events: a, accounts: r };
  }
  return t;
}
function K2(s) {
  return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
var Pt2 = {};
var h = (s) => Pt2[s];
var V3 = (s, t) => {
  Pt2[s] = t;
};
var fe = Object.defineProperty;
var me3 = (s, t, e) => t in s ? fe(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var O = (s, t, e) => me3(s, typeof t != "symbol" ? t + "" : t, e);
var ve2 = class {
  constructor(t) {
    O(this, "name", "polkadot"), O(this, "client"), O(this, "httpProviders"), O(this, "events"), O(this, "namespace"), O(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace, this.client.core.projectId);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
};
var ge2 = Object.defineProperty;
var Pe2 = Object.defineProperties;
var we3 = Object.getOwnPropertyDescriptors;
var wt3 = Object.getOwnPropertySymbols;
var ye2 = Object.prototype.hasOwnProperty;
var be2 = Object.prototype.propertyIsEnumerable;
var X2 = (s, t, e) => t in s ? ge2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var yt3 = (s, t) => {
  for (var e in t || (t = {})) ye2.call(t, e) && X2(s, e, t[e]);
  if (wt3) for (var e of wt3(t)) be2.call(t, e) && X2(s, e, t[e]);
  return s;
};
var bt2 = (s, t) => Pe2(s, we3(t));
var A = (s, t, e) => X2(s, typeof t != "symbol" ? t + "" : t, e);
var Ie2 = class {
  constructor(t) {
    A(this, "name", "eip155"), A(this, "client"), A(this, "chainId"), A(this, "namespace"), A(this, "httpProviders"), A(this, "events"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t);
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  createHttpProvider(t, e) {
    const i2 = e || d(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      const n2 = parseInt(b2(e));
      t[n2] = this.createHttpProvider(n2, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t = this.chainId, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  async handleSwitchChain(t) {
    var e, i2;
    let n2 = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
    n2 = n2.startsWith("0x") ? n2 : `0x${n2}`;
    const a = parseInt(n2, 16);
    if (this.isChainApproved(a)) this.setDefaultChain(`${a}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t.topic, request: { method: t.request.method, params: [{ chainId: n2 }] }, chainId: (i2 = this.namespace.chains) == null ? void 0 : i2[0] }), this.setDefaultChain(`${a}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`);
  }
  async getCapabilities(t) {
    var e, i2, n2, a, r;
    const c2 = (i2 = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i2[0], o2 = ((a = (n2 = t.request) == null ? void 0 : n2.params) == null ? void 0 : a[1]) || [], m = `${c2}${o2.join(",")}`;
    if (!c2) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const w = this.client.session.get(t.topic), v2 = ((r = w?.sessionProperties) == null ? void 0 : r.capabilities) || {};
    if (v2 != null && v2[m]) return v2?.[m];
    const P = await this.client.request(t);
    try {
      await this.client.session.update(t.topic, { sessionProperties: bt2(yt3({}, w.sessionProperties || {}), { capabilities: bt2(yt3({}, v2 || {}), { [m]: P }) }) });
    } catch (p) {
      console.warn("Failed to update session with capabilities", p);
    }
    return P;
  }
  async getCallStatus(t) {
    var e, i2;
    const n2 = this.client.session.get(t.topic), a = (e = n2.sessionProperties) == null ? void 0 : e.bundler_name;
    if (a) {
      const c2 = this.getBundlerUrl(t.chainId, a);
      try {
        return await this.getUserOperationReceipt(c2, t);
      } catch (o2) {
        console.warn("Failed to fetch call status from bundler", o2, c2);
      }
    }
    const r = (i2 = n2.sessionProperties) == null ? void 0 : i2.bundler_url;
    if (r) try {
      return await this.getUserOperationReceipt(r, t);
    } catch (c2) {
      console.warn("Failed to fetch call status from custom bundler", c2, r);
    }
    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t, e) {
    var i2;
    const n2 = new URL(t), a = await fetch(n2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i2 = e.request.params) == null ? void 0 : i2[0]])) });
    if (!a.ok) throw new Error(`Failed to fetch user operation receipt - ${a.status}`);
    return await a.json();
  }
  getBundlerUrl(t, e) {
    return `${jt2}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
  }
};
var $e2 = Object.defineProperty;
var Oe3 = (s, t, e) => t in s ? $e2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var C4 = (s, t, e) => Oe3(s, typeof t != "symbol" ? t + "" : t, e);
var Ae2 = class {
  constructor(t) {
    C4(this, "name", "solana"), C4(this, "client"), C4(this, "httpProviders"), C4(this, "events"), C4(this, "namespace"), C4(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace, this.client.core.projectId);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
};
var Ce2 = Object.defineProperty;
var He2 = (s, t, e) => t in s ? Ce2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var H2 = (s, t, e) => He2(s, typeof t != "symbol" ? t + "" : t, e);
var Ee3 = class {
  constructor(t) {
    H2(this, "name", "cosmos"), H2(this, "client"), H2(this, "httpProviders"), H2(this, "events"), H2(this, "namespace"), H2(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace, this.client.core.projectId);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
};
var Ne2 = Object.defineProperty;
var Se = (s, t, e) => t in s ? Ne2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var E3 = (s, t, e) => Se(s, typeof t != "symbol" ? t + "" : t, e);
var De3 = class {
  constructor(t) {
    E3(this, "name", "algorand"), E3(this, "client"), E3(this, "httpProviders"), E3(this, "events"), E3(this, "namespace"), E3(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (!this.httpProviders[t]) {
      const i2 = e || d(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
      if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i2);
    }
    this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      t[e] = this.createHttpProvider(e, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace, this.client.core.projectId);
    return typeof i2 > "u" ? void 0 : new o(new f(i2, h("disableProviderPing")));
  }
};
var qe2 = Object.defineProperty;
var je = (s, t, e) => t in s ? qe2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var N2 = (s, t, e) => je(s, typeof t != "symbol" ? t + "" : t, e);
var Re = class {
  constructor(t) {
    N2(this, "name", "cip34"), N2(this, "client"), N2(this, "httpProviders"), N2(this, "events"), N2(this, "namespace"), N2(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      const i2 = this.getCardanoRPCUrl(e), n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, i2);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  getCardanoRPCUrl(t) {
    const e = this.namespace.rpcMap;
    if (e) return e[t];
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || this.getCardanoRPCUrl(t);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
};
var _e3 = Object.defineProperty;
var Ue2 = (s, t, e) => t in s ? _e3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var S = (s, t, e) => Ue2(s, typeof t != "symbol" ? t + "" : t, e);
var Fe2 = class {
  constructor(t) {
    S(this, "name", "elrond"), S(this, "client"), S(this, "httpProviders"), S(this, "events"), S(this, "namespace"), S(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace, this.client.core.projectId);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
};
var Le2 = Object.defineProperty;
var Me3 = (s, t, e) => t in s ? Le2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var D = (s, t, e) => Me3(s, typeof t != "symbol" ? t + "" : t, e);
var xe2 = class {
  constructor(t) {
    D(this, "name", "multiversx"), D(this, "client"), D(this, "httpProviders"), D(this, "events"), D(this, "namespace"), D(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      const n2 = b2(e);
      t[n2] = this.createHttpProvider(n2, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace, this.client.core.projectId);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
};
var Be2 = Object.defineProperty;
var Ge3 = (s, t, e) => t in s ? Be2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var q2 = (s, t, e) => Ge3(s, typeof t != "symbol" ? t + "" : t, e);
var Je2 = class {
  constructor(t) {
    q2(this, "name", "near"), q2(this, "client"), q2(this, "httpProviders"), q2(this, "events"), q2(this, "namespace"), q2(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i2 = e || d(`${this.name}:${t}`, this.namespace);
      if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i2);
    }
    this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i2;
      t[e] = this.createHttpProvider(e, (i2 = this.namespace.rpcMap) == null ? void 0 : i2[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace);
    return typeof i2 > "u" ? void 0 : new o(new f(i2, h("disableProviderPing")));
  }
};
var ze2 = Object.defineProperty;
var ke3 = (s, t, e) => t in s ? ze2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var j = (s, t, e) => ke3(s, typeof t != "symbol" ? t + "" : t, e);
var We3 = class {
  constructor(t) {
    j(this, "name", "tezos"), j(this, "client"), j(this, "httpProviders"), j(this, "events"), j(this, "namespace"), j(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i2 = e || d(`${this.name}:${t}`, this.namespace);
      if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i2);
    }
    this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      t[e] = this.createHttpProvider(e);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace);
    return typeof i2 > "u" ? void 0 : new o(new f(i2));
  }
};
var Ke3 = Object.defineProperty;
var Ve2 = (s, t, e) => t in s ? Ke3(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var R = (s, t, e) => Ve2(s, typeof t != "symbol" ? t + "" : t, e);
var Xe2 = class {
  constructor(t) {
    R(this, "name", I), R(this, "client"), R(this, "httpProviders"), R(this, "events"), R(this, "namespace"), R(this, "chainId"), this.namespace = t.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t, e;
    const i2 = {};
    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((n2) => {
      const a = Ne(n2);
      i2[`${a.namespace}:${a.reference}`] = this.createHttpProvider(n2);
    }), i2;
  }
  getHttpProvider(t) {
    const e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i2 = this.createHttpProvider(t, e);
    i2 && (this.httpProviders[t] = i2);
  }
  createHttpProvider(t, e) {
    const i2 = e || d(t, this.namespace, this.client.core.projectId);
    if (!i2) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f(i2, h("disableProviderPing")));
  }
};
var Ye2 = Object.defineProperty;
var Qe2 = Object.defineProperties;
var Ze3 = Object.getOwnPropertyDescriptors;
var It2 = Object.getOwnPropertySymbols;
var Te = Object.prototype.hasOwnProperty;
var ts2 = Object.prototype.propertyIsEnumerable;
var Y3 = (s, t, e) => t in s ? Ye2(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var x = (s, t) => {
  for (var e in t || (t = {})) Te.call(t, e) && Y3(s, e, t[e]);
  if (It2) for (var e of It2(t)) ts2.call(t, e) && Y3(s, e, t[e]);
  return s;
};
var Q2 = (s, t) => Qe2(s, Ze3(t));
var l2 = (s, t, e) => Y3(s, typeof t != "symbol" ? t + "" : t, e);
var B = class _B {
  constructor(t) {
    l2(this, "client"), l2(this, "namespaces"), l2(this, "optionalNamespaces"), l2(this, "sessionProperties"), l2(this, "scopedProperties"), l2(this, "events", new import_events4.default()), l2(this, "rpcProviders", {}), l2(this, "session"), l2(this, "providerOpts"), l2(this, "logger"), l2(this, "uri"), l2(this, "disableProviderPing", false), this.providerOpts = t, this.logger = typeof t?.logger < "u" && typeof t?.logger != "string" ? t.logger : (0, import_pino.default)(k({ level: t?.logger || et2 })), this.disableProviderPing = t?.disableProviderPing || false;
  }
  static async init(t) {
    const e = new _B(t);
    return await e.initialize(), e;
  }
  async request(t, e, i2) {
    const [n2, a] = this.validateChain(e);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(n2).request({ request: x({}, t), chainId: `${n2}:${a}`, topic: this.session.topic, expiry: i2 });
  }
  sendAsync(t, e, i2, n2) {
    const a = (/* @__PURE__ */ new Date()).getTime();
    this.request(t, i2, n2).then((r) => e(null, formatJsonRpcResult(a, r))).catch((r) => e(r, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t = this.session) == null ? void 0 : t.topic, reason: Nt("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
  }
  async authenticate(t, e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t), await this.cleanupPendingPairings();
    const { uri: i2, response: n2 } = await this.client.authenticate(t, e);
    i2 && (this.uri = i2, this.events.emit("display_uri", i2));
    const a = await n2();
    if (this.session = a.session, this.session) {
      const r = gt3(this.session.namespaces);
      this.namespaces = M2(this.namespaces, r), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a;
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t) {
    const { uri: e, approval: i2 } = await this.client.connect({ pairingTopic: t, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e && (this.uri = e, this.events.emit("display_uri", e));
    const n2 = await i2();
    this.session = n2;
    const a = gt3(n2.namespaces);
    return this.namespaces = M2(this.namespaces, a), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t, e) {
    try {
      if (!this.session) return;
      const [i2, n2] = this.validateChain(t), a = this.getProvider(i2);
      a.name === I ? a.setDefaultChain(`${i2}:${n2}`, e) : a.setDefaultChain(n2, e);
    } catch (i2) {
      if (!/Please call connect/.test(i2.message)) throw i2;
    }
  }
  async cleanupPendingPairings(t = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const e = this.client.pairing.getAll();
    if (se(e)) {
      for (const i2 of e) t.deletePairings ? this.client.core.expirer.set(i2.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i2.topic);
      this.logger.info(`Inactive pairings cleared: ${e.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t, e;
    if (this.client = this.providerOpts.client || await Ee2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || et2, relayUrl: this.providerOpts.relayUrl || St3, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (i2) {
      throw this.logger.error("Failed to get session", i2), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
    }
    else {
      const i2 = this.client.session.getAll();
      this.session = i2[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map((e) => yo(e)))];
    V3("client", this.client), V3("events", this.events), V3("disableProviderPing", this.disableProviderPing), t.forEach((e) => {
      if (!this.session) return;
      const i2 = le2(e, this.session), n2 = ft3(i2), a = M2(this.namespaces, this.optionalNamespaces), r = Q2(x({}, a[e]), { accounts: i2, chains: n2 });
      switch (e) {
        case "eip155":
          this.rpcProviders[e] = new Ie2({ namespace: r });
          break;
        case "algorand":
          this.rpcProviders[e] = new De3({ namespace: r });
          break;
        case "solana":
          this.rpcProviders[e] = new Ae2({ namespace: r });
          break;
        case "cosmos":
          this.rpcProviders[e] = new Ee3({ namespace: r });
          break;
        case "polkadot":
          this.rpcProviders[e] = new ve2({ namespace: r });
          break;
        case "cip34":
          this.rpcProviders[e] = new Re({ namespace: r });
          break;
        case "elrond":
          this.rpcProviders[e] = new Fe2({ namespace: r });
          break;
        case "multiversx":
          this.rpcProviders[e] = new xe2({ namespace: r });
          break;
        case "near":
          this.rpcProviders[e] = new Je2({ namespace: r });
          break;
        case "tezos":
          this.rpcProviders[e] = new We3({ namespace: r });
          break;
        default:
          this.rpcProviders[I] ? this.rpcProviders[I].updateNamespace(r) : this.rpcProviders[I] = new Xe2({ namespace: r });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t) => {
      var e;
      const { topic: i2 } = t;
      i2 === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
    }), this.client.on("session_event", (t) => {
      var e;
      const { params: i2, topic: n2 } = t;
      if (n2 !== ((e = this.session) == null ? void 0 : e.topic)) return;
      const { event: a } = i2;
      if (a.name === "accountsChanged") {
        const r = a.data;
        r && se(r) && this.events.emit("accountsChanged", r.map(vt));
      } else if (a.name === "chainChanged") {
        const r = i2.chainId, c2 = i2.event.data, o2 = yo(r), m = K2(r) !== K2(c2) ? `${o2}:${K2(c2)}` : r;
        this.onChainChanged(m);
      } else this.events.emit(a.name, a.data);
      this.events.emit("session_event", t);
    }), this.client.on("session_update", ({ topic: t, params: e }) => {
      var i2, n2;
      if (t !== ((i2 = this.session) == null ? void 0 : i2.topic)) return;
      const { namespaces: a } = e, r = (n2 = this.client) == null ? void 0 : n2.session.get(t);
      this.session = Q2(x({}, r), { namespaces: a }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t, params: e });
    }), this.client.on("session_delete", async (t) => {
      var e;
      t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", Q2(x({}, Nt("USER_DISCONNECTED")), { data: t.topic })));
    }), this.on(u.DEFAULT_CHAIN_CHANGED, (t) => {
      this.onChainChanged(t, true);
    });
  }
  getProvider(t) {
    return this.rpcProviders[t] || this.rpcProviders[I];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t) => {
      var e;
      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
    });
  }
  setNamespaces(t) {
    const { namespaces: e = {}, optionalNamespaces: i2 = {}, sessionProperties: n2, scopedProperties: a } = t;
    this.optionalNamespaces = M2(e, i2), this.sessionProperties = n2, this.scopedProperties = a;
  }
  validateChain(t) {
    const [e, i2] = t?.split(":") || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i2];
    if (e && !Object.keys(this.namespaces || {}).map((r) => yo(r)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
    if (e && i2) return [e, i2];
    const n2 = yo(Object.keys(this.namespaces)[0]), a = this.rpcProviders[n2].getDefaultChain();
    return [n2, a];
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts();
  }
  async onChainChanged(t, e = false) {
    if (!this.namespaces) return;
    const [i2, n2] = this.validateChain(t);
    if (!n2) return;
    this.updateNamespaceChain(i2, n2), this.events.emit("chainChanged", n2);
    const a = this.getProvider(i2).getDefaultChain();
    e || this.getProvider(i2).setDefaultChain(n2), this.emitAccountsChangedOnChainChange({ namespace: i2, previousChainId: a, newChainId: t }), await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({ namespace: t, previousChainId: e, newChainId: i2 }) {
    var n2, a;
    try {
      if (e === i2) return;
      const r = (a = (n2 = this.session) == null ? void 0 : n2.namespaces[t]) == null ? void 0 : a.accounts;
      if (!r) return;
      const c2 = r.filter((o2) => o2.includes(`${i2}:`)).map(vt);
      if (!se(c2)) return;
      this.events.emit("accountsChanged", c2);
    } catch (r) {
      this.logger.warn("Failed to emit accountsChanged on chain change", r);
    }
  }
  updateNamespaceChain(t, e) {
    if (!this.namespaces) return;
    const i2 = this.namespaces[t] ? t : `${t}:${e}`, n2 = { chains: [], methods: [], events: [], defaultChain: e };
    this.namespaces[i2] ? this.namespaces[i2] && (this.namespaces[i2].defaultChain = e) : this.namespaces[i2] = n2;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t, e) {
    var i2;
    const n2 = ((i2 = this.session) == null ? void 0 : i2.topic) || "";
    await this.client.core.storage.setItem(`${U3}/${t}${n2}`, e);
  }
  async getFromStore(t) {
    var e;
    const i2 = ((e = this.session) == null ? void 0 : e.topic) || "";
    return await this.client.core.storage.getItem(`${U3}/${t}${i2}`);
  }
  async deleteFromStore(t) {
    var e;
    const i2 = ((e = this.session) == null ? void 0 : e.topic) || "";
    await this.client.core.storage.removeItem(`${U3}/${t}${i2}`);
  }
  async cleanupStorage() {
    var t;
    try {
      if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
      const e = await this.client.core.storage.getKeys();
      for (const i2 of e) i2.startsWith(U3) && await this.client.core.storage.removeItem(i2);
    } catch (e) {
      this.logger.warn("Failed to cleanup storage", e);
    }
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js
function checkNamespaceConnectorId(namespace, connectorId) {
  return ConnectorController.getConnectorId(namespace) === connectorId;
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js
function getChainsToDisconnect(namespace) {
  const namespaces = Array.from(ChainController.state.chains.keys());
  let chains = [];
  if (namespace) {
    chains.push([namespace, ChainController.state.chains.get(namespace)]);
    if (checkNamespaceConnectorId(namespace, ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT)) {
      namespaces.forEach((ns2) => {
        if (ns2 !== namespace && checkNamespaceConnectorId(ns2, ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT)) {
          chains.push([ns2, ChainController.state.chains.get(ns2)]);
        }
      });
    } else if (checkNamespaceConnectorId(namespace, ConstantsUtil.CONNECTOR_ID.AUTH)) {
      namespaces.forEach((ns2) => {
        if (ns2 !== namespace && checkNamespaceConnectorId(ns2, ConstantsUtil.CONNECTOR_ID.AUTH)) {
          chains.push([ns2, ChainController.state.chains.get(ns2)]);
        }
      });
    }
  } else {
    chains = Array.from(ChainController.state.chains.entries());
  }
  return chains;
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org"
  ]
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain2(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
var solana = defineChain2({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
var solanaDevnet = defineChain2({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
var solanaTestnet = defineChain2({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
var bitcoin = defineChain2({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
var bitcoinTestnet = defineChain2({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns2) => namespacesToOverride.add(ns2));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns2) => namespacesToOverride.add(ns2));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns2) => namespacesToOverride.add(ns2));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns2] = chainId.split(":");
        if (ns2) {
          namespacesToOverride.add(ns2);
        }
      });
    }
    namespacesToOverride.forEach((ns2) => {
      if (!result[ns2]) {
        result[ns2] = this.createDefaultNamespace(ns2);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns2, methods]) => {
        if (result[ns2]) {
          result[ns2].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns2, chains]) => {
        if (result[ns2]) {
          result[ns2].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns2, events]) => {
        if (result[ns2]) {
          result[ns2].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns2, id] = chainId.split(":");
        if (!ns2 || !id || !result[ns2]) {
          return;
        }
        if (!result[ns2].rpcMap) {
          result[ns2].rpcMap = {};
        }
        if (!processedNamespaces.has(ns2)) {
          result[ns2].rpcMap = {};
          processedNamespaces.add(ns2);
        }
        result[ns2].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if (namespace?.rpcMap && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name) => {
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress?.addresses) || [];
    return networkNameAddresses[0]?.address || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  },
  isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
    for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
      if (pattern.includes("*")) {
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        const regexString = `^${escapedPattern.replace(/\\\*/gu, ".*")}$`;
        const regex = new RegExp(regexString, "u");
        if (regex.test(currentOrigin)) {
          return true;
        }
      } else {
        try {
          if (new URL(pattern).origin === currentOrigin) {
            return true;
          }
        } catch (e) {
          if (pattern === currentOrigin) {
            return true;
          }
        }
      }
    }
    return false;
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.getCaipNetworks = ChainController.getCaipNetworks.bind(ChainController);
    this.caipNetworks = this.getCaipNetworks();
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const caipNetworks = this.getCaipNetworks();
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({ optionalNamespaces: namespaces });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.eventListeners = /* @__PURE__ */ new Map();
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    if (params) {
      this.construct(params);
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  setStatus(status, chainNamespace) {
    AccountController.setStatus(status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(eventName)?.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    const connector = this.getWalletConnectConnector();
    const result = await connector.connectWalletConnect();
    return { clientId: result.clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      ;
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      const preferredAccountType = AccountController.state.preferredAccountTypes?.[caipNetwork.chainNamespace];
      await authProvider.switchNetwork(caipNetwork.caipNetworkId);
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c2) => c2 instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  setUniversalProvider(universalProvider) {
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: this.namespace
    }));
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
    } catch (error) {
      console.warn("UniversalAdapter:disconnect - error", error);
    }
  }
  async getAccounts({ namespace }) {
    const provider = this.provider;
    const addresses = provider?.session?.namespaces?.[namespace]?.accounts?.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index, self) => self.indexOf(address) === index) || [];
    return Promise.resolve({
      accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    const isBalanceSupported = params.caipNetwork && ConstantsUtil2.BALANCE_SUPPORTED_CHAINS.includes(params.caipNetwork?.chainNamespace);
    if (!isBalanceSupported || params.caipNetwork?.testnet) {
      return {
        balance: "0.00",
        symbol: params.caipNetwork?.nativeCurrency.symbol || ""
      };
    }
    if (AccountController.state.balanceLoading && params.chainId === ChainController.state.activeCaipNetwork?.id) {
      return {
        balance: AccountController.state.balance || "0.00",
        symbol: AccountController.state.balanceSymbol || ""
      };
    }
    const balances = await AccountController.fetchTokenBalance();
    const balance = balances.find((b3) => b3.chainId === `${params.caipNetwork?.chainNamespace}:${params.chainId}` && b3.symbol === params.caipNetwork?.nativeCurrency.symbol);
    return {
      balance: balance?.quantity.numeric || "0.00",
      symbol: balance?.symbol || params.caipNetwork?.nativeCurrency.symbol || ""
    };
  }
  async signMessage(params) {
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature = "";
    if (ChainController.state.activeCaipNetwork?.chainNamespace === ConstantsUtil.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: esm_default.encode(new TextEncoder().encode(message)),
          pubkey: address
        }
      }, ChainController.state.activeCaipNetwork?.caipNetworkId);
      signature = response.signature;
    } else {
      signature = await provider.request({
        method: "personal_sign",
        params: [message, address]
      }, ChainController.state.activeCaipNetwork?.caipNetworkId);
    }
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      try {
        await connector.provider?.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex(caipNetwork.id) }]
        });
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await connector.provider?.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex(caipNetwork.id),
                  rpcUrls: [caipNetwork?.rpcUrls["chainDefault"]?.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [caipNetwork.blockExplorers?.default.url]
                }
              ]
            });
          } catch (error) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    const provider = connector?.provider;
    return provider;
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/utils/ConfigUtil.js
var FEATURE_KEYS = [
  "email",
  "socials",
  "swaps",
  "onramp",
  "activity",
  "reownBranding"
];
var featureConfig = {
  email: {
    apiFeatureName: "social_login",
    localFeatureName: "email",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.includes("email");
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.email;
      }
      return Boolean(localValue);
    }
  },
  socials: {
    apiFeatureName: "social_login",
    localFeatureName: "socials",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config.filter((s) => s !== "email") : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials : false;
      }
      return localValue;
    }
  },
  swaps: {
    apiFeatureName: "swap",
    localFeatureName: "swaps",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps : false;
      }
      return localValue;
    }
  },
  onramp: {
    apiFeatureName: "onramp",
    localFeatureName: "onramp",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp : false;
      }
      return localValue;
    }
  },
  activity: {
    apiFeatureName: "activity",
    localFeatureName: "history",
    returnType: false,
    isLegacy: true,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.activity;
      }
      return Boolean(localValue);
    }
  },
  reownBranding: {
    apiFeatureName: "reown_branding",
    localFeatureName: "reownBranding",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownBranding;
      }
      return Boolean(localValue);
    }
  }
};
var ConfigUtil = {
  localSettingsOverridden: /* @__PURE__ */ new Set(),
  getApiConfig(id, apiProjectConfig) {
    return apiProjectConfig?.find((f2) => f2.id === id);
  },
  addWarning(localFeatureValue, featureKey) {
    if (localFeatureValue !== void 0) {
      const config = featureConfig[featureKey];
      const warningName = config.isLegacy ? `"features.${config.localFeatureName}" (now "${featureKey}")` : `"features.${featureKey}"`;
      this.localSettingsOverridden.add(warningName);
    }
  },
  processFeature(featureKey, localFeatures, apiProjectConfig, useApi, isBasic) {
    const config = featureConfig[featureKey];
    const localValue = localFeatures[config.localFeatureName];
    if (isBasic && !config.isAvailableOnBasic) {
      return false;
    }
    if (useApi) {
      const apiConfig = this.getApiConfig(config.apiFeatureName, apiProjectConfig);
      if (apiConfig?.config === null) {
        return this.processFallbackFeature(featureKey, localValue);
      }
      if (!apiConfig?.config) {
        return false;
      }
      if (localValue !== void 0) {
        this.addWarning(localValue, featureKey);
      }
      return this.processApiFeature(featureKey, apiConfig);
    }
    return this.processFallbackFeature(featureKey, localValue);
  },
  processApiFeature(featureKey, apiConfig) {
    return featureConfig[featureKey].processApi(apiConfig);
  },
  processFallbackFeature(featureKey, localValue) {
    return featureConfig[featureKey].processFallback(localValue);
  },
  async fetchRemoteFeatures(config) {
    const isBasic = config.basic ?? false;
    const localFeatures = config.features || {};
    this.localSettingsOverridden.clear();
    let apiProjectConfig = null;
    let useApiConfig = false;
    try {
      apiProjectConfig = await ApiController.fetchProjectConfig();
      useApiConfig = apiProjectConfig !== null && apiProjectConfig !== void 0;
    } catch (e) {
      console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.", e);
    }
    const remoteFeaturesConfig = useApiConfig && !isBasic ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES : ConstantsUtil2.DEFAULT_REMOTE_FEATURES_DISABLED;
    try {
      for (const featureKey of FEATURE_KEYS) {
        const result = this.processFeature(featureKey, localFeatures, apiProjectConfig, useApiConfig, isBasic);
        Object.assign(remoteFeaturesConfig, { [featureKey]: result });
      }
    } catch (e) {
      console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.", e);
      return ConstantsUtil2.DEFAULT_REMOTE_FEATURES;
    }
    if (useApiConfig && this.localSettingsOverridden.size > 0) {
      const warningMessage = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
      AlertController.open({
        shortMessage: "Local configuration ignored",
        longMessage: `[Reown Config Notice] ${warningMessage}`
      }, "warning");
    }
    return remoteFeaturesConfig;
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
  constructor(options) {
    this.chainNamespaces = [];
    this.remoteFeatures = {};
    this.reportedAlertErrors = {};
    this.getCaipNetwork = (chainNamespace, id) => {
      if (chainNamespace) {
        const caipNetworkWithId = ChainController.getNetworkData(chainNamespace)?.requestedCaipNetworks?.find((c2) => c2.id === id);
        if (caipNetworkWithId) {
          return caipNetworkWithId;
        }
        const namespaceCaipNetwork = ChainController.getNetworkData(chainNamespace)?.caipNetwork;
        if (namespaceCaipNetwork) {
          return namespaceCaipNetwork;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(chainNamespace);
        return requestedCaipNetworks.filter((c2) => c2.chainNamespace === chainNamespace)?.[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.getCaipAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return ChainController.getAccountProp("caipAddress", chainNamespace);
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
    this.getPreferredAccountType = (namespace) => AccountController.state.preferredAccountTypes?.[namespace];
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
      if (caipAddress && OptionsController.state.enableEmbedded) {
        this.close();
      }
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.setUser = (user, chain) => {
      AccountController.setUser(user, chain);
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
      ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
    };
    this.setAllAccounts = (addresses, chain) => {
      AccountController.setAllAccounts(addresses, chain);
      OptionsController.setHasMultipleAddresses(addresses?.length > 1);
    };
    this.setStatus = (status, chain) => {
      AccountController.setStatus(status, chain);
      if (ConnectorController.isConnected()) {
        StorageUtil.setConnectionStatus("connected");
      } else {
        StorageUtil.setConnectionStatus("disconnected");
      }
    };
    this.getAddressByChainNamespace = (chainNamespace) => ChainController.getAccountProp("address", chainNamespace);
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.state.allConnectors, ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.setConnections = (connections, chainNamespace) => {
      ConnectionController.setConnections(connections, chainNamespace);
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.getConnectors = () => ConnectorController.getConnectors();
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      const type = ProviderUtil.getProviderId(chain);
      const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : void 0;
      AccountController.setConnectedWalletInfo(walletInfo, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return ChainController.getAccountProp("address", chainNamespace);
    };
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
      ChainController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      AccountController.setPreferredAccountType(preferredAccountType, chain);
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = this.getChainNamespacesSet(options.adapters, this.caipNetworks);
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.readyPromise = this.initialize(options);
  }
  getChainNamespacesSet(adapters, caipNetworks) {
    const adapterNamespaces = adapters?.map((adapter) => adapter.namespace).filter((namespace) => Boolean(namespace));
    if (adapterNamespaces?.length) {
      return [...new Set(adapterNamespaces)];
    }
    const networkNamespaces = caipNetworks?.map((network) => network.chainNamespace);
    return [...new Set(networkNamespaces)];
  }
  async initialize(options) {
    this.initializeProjectSettings(options);
    this.initControllers(options);
    await this.initChainAdapters();
    this.sendInitializeEvent(options);
    await this.syncExistingConnection();
    this.remoteFeatures = await ConfigUtil.fetchRemoteFeatures(options);
    OptionsController.setRemoteFeatures(this.remoteFeatures);
    if (this.remoteFeatures.onramp) {
      OnRampController.setOnrampProviders(this.remoteFeatures.onramp);
    }
    if (OptionsController.state.remoteFeatures?.email || Array.isArray(OptionsController.state.remoteFeatures?.socials) && OptionsController.state.remoteFeatures?.socials.length > 0) {
      await this.checkAllowedOrigins();
    }
  }
  async checkAllowedOrigins() {
    const allowedOrigins = await ApiController.fetchAllowedOrigins();
    if (allowedOrigins && CoreHelperUtil.isClient()) {
      const currentOrigin = window.location.origin;
      const isOriginAllowed = WcHelpersUtil.isOriginAllowed(currentOrigin, allowedOrigins, WcConstantsUtil.DEFAULT_ALLOWED_ANCESTORS);
      if (!isOriginAllowed) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.INVALID_APP_CONFIGURATION, "error");
      }
    } else {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
    }
  }
  sendInitializeEvent(options) {
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    delete optionsCopy.universalProvider;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n2) => n2.id),
        siweConfig: {
          options: options.siweConfig?.options || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeConnectionController(options);
    this.initializeConnectorController();
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  initializeConnectionController(options) {
    ConnectionController.setWcBasic(options.basic ?? false);
  }
  initializeConnectorController() {
    ConnectorController.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(options) {
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
  }
  initializeOptionsController(options) {
    OptionsController.setDebug(options.debug !== false);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setCustomRpcUrls(options.customRpcUrls);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
    OptionsController.setPreferUniversalLinks(options.experimental_preferUniversalLinks);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    const storedAccountTypes = StorageUtil.getPreferredAccountTypes() || {};
    const defaultTypes = { ...OptionsController.state.defaultAccountTypes, ...storedAccountTypes };
    AccountController.setPreferredAccountTypes(defaultTypes);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    const evmAdapter = options.adapters?.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  getDefaultMetaData() {
    if (CoreHelperUtil.isClient()) {
      return {
        name: document.getElementsByTagName("title")?.[0]?.textContent || "",
        description: document.querySelector('meta[property="og:description"]')?.content || "",
        url: window.location.origin,
        icons: [document.querySelector('link[rel~="icon"]')?.href || ""]
      };
    }
    return null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  getDefaultNetwork() {
    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n2) => n2.id === options.defaultNetwork?.id);
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  async disconnectNamespace(namespace) {
    try {
      const adapter = this.getAdapter(namespace);
      const provider = ProviderUtil.getProvider(namespace);
      const providerType = ProviderUtil.getProviderId(namespace);
      const { caipAddress } = ChainController.getAccountData(namespace) || {};
      this.setLoading(true, namespace);
      if (caipAddress && adapter?.disconnect) {
        await adapter.disconnect({ provider, providerType });
      }
      StorageUtil.removeConnectedNamespace(namespace);
      ProviderUtil.resetChain(namespace);
      this.setUser(void 0, namespace);
      this.setStatus("disconnected", namespace);
      this.setConnectedWalletInfo(void 0, namespace);
      ConnectorController.removeConnectorId(namespace);
      ChainController.resetAccount(namespace);
      ChainController.resetNetwork(namespace);
      this.setLoading(false, namespace);
    } catch (error) {
      this.setLoading(false, namespace);
      throw new Error(`Failed to disconnect chain ${namespace}: ${error.message}`);
    }
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        const activeChain = ChainController.state.activeChain;
        const adapter = this.getAdapter(activeChain);
        const chainId = this.getCaipNetwork(activeChain)?.id;
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect(chainId);
        this.close();
        this.setClientId(result?.clientId || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        this.chainNamespaces.forEach((namespace) => {
          ConnectorController.setConnectorId(ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT, namespace);
        });
        await this.syncWalletConnectAccount();
      },
      connectExternal: async ({ id, info, type, provider, chain, caipNetwork, socialUri }) => {
        const activeChain = ChainController.state.activeChain;
        const chainToUse = chain || activeChain;
        const adapter = this.getAdapter(chainToUse);
        if (chain && chain !== activeChain && !caipNetwork) {
          const toConnectNetwork = this.getCaipNetworks().find((network) => network.chainNamespace === chain);
          if (toConnectNetwork) {
            this.setCaipNetwork(toConnectNetwork);
          }
        }
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const fallbackCaipNetwork = this.getCaipNetwork(chainToUse);
        const res = await adapter.connect({
          id,
          info,
          type,
          provider,
          socialUri,
          chainId: caipNetwork?.id || fallbackCaipNetwork?.id,
          rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0] || fallbackCaipNetwork?.rpcUrls?.default?.http?.[0]
        });
        if (!res) {
          return;
        }
        StorageUtil.addConnectedNamespace(chainToUse);
        this.syncProvider({ ...res, chainNamespace: chainToUse });
        const syncedAccounts = AccountController.state.allAccounts;
        const { accounts } = syncedAccounts?.length > 0 ? (
          // eslint-disable-next-line line-comment-position
          // Using new array else the accounts will have the same reference and react will not re-render
          { accounts: [...syncedAccounts] }
        ) : await adapter.getAccounts({ namespace: chainToUse, id });
        this.setAllAccounts(accounts, chainToUse);
        this.setStatus("connected", chainToUse);
        this.syncConnectedWalletInfo(chainToUse);
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (adapter?.reconnect) {
          await adapter?.reconnect({ id, info, type, provider, chainId: this.getCaipNetwork()?.id });
          StorageUtil.addConnectedNamespace(namespace);
          this.syncConnectedWalletInfo(namespace);
        }
      },
      disconnect: async (chainNamespace) => {
        const chainsToDisconnect = getChainsToDisconnect(chainNamespace);
        try {
          const disconnectResults = await Promise.allSettled(chainsToDisconnect.map(async ([ns2]) => this.disconnectNamespace(ns2)));
          SendController.resetSend();
          ConnectionController.resetWcConnection();
          await SIWXUtil.clearSessions();
          ConnectorController.setFilterByNamespace(void 0);
          const failures = disconnectResults.filter((result) => result.status === "rejected");
          if (failures.length > 0) {
            throw new Error(failures.map((f2) => f2.reason.message).join(", "));
          }
          StorageUtil.deleteConnectedSocialProvider();
          EventsController.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: {
              namespace: chainNamespace || "all"
            }
          });
        } catch (error) {
          throw new Error(`Failed to disconnect chains: ${error.message}`);
        }
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => Boolean(window.ethereum?.[String(id)]));
      },
      signMessage: async (message) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await adapter?.signMessage({
          message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(ChainController.state.activeChain)
        });
        return result?.signature || "";
      },
      sendTransaction: async (args) => {
        const namespace = args.chainNamespace;
        if (ConstantsUtil2.SEND_SUPPORTED_NAMESPACES.includes(namespace)) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(namespace);
          const result = await adapter?.sendTransaction({
            ...args,
            caipNetwork: this.getCaipNetwork(),
            provider
          });
          return result?.hash || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("CaipNetwork is undefined");
          }
          const result = await adapter?.estimateGas({
            ...args,
            provider,
            caipNetwork
          });
          return result?.gas || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        await this.syncIdentity({
          address: AccountController.state.address,
          chainId: Number(this.getCaipNetwork()?.id),
          chainNamespace: ChainController.state.activeChain
        });
        return AccountController.state.profileImage || false;
      },
      getEnsAddress: async (name) => await WcHelpersUtil.resolveReownName(name),
      writeContract: async (args) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
        if (!caipNetwork || !caipAddress) {
          throw new Error("CaipNetwork or CaipAddress is undefined");
        }
        const result = await adapter?.writeContract({ ...args, caipNetwork, provider, caipAddress });
        return result?.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return adapter?.parseUnits({ value, decimals }) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return adapter?.formatUnits({ value, decimals }) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await adapter?.getCapabilities(params);
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await adapter?.grantPermissions(params);
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (adapter?.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await adapter?.walletGetAssets(params) ?? {};
      },
      updateBalance: (namespace) => {
        const caipNetwork = this.getCaipNetwork(namespace);
        if (!caipNetwork || !AccountController.state.address) {
          return;
        }
        this.updateNativeBalance(AccountController.state.address, caipNetwork?.id, namespace);
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    const providerType = ProviderUtil.getProviderId(ChainController.state.activeChain);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const namespaces = this.universalProvider?.session?.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: this.universalProvider?.session?.peer?.metadata.name === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
      };
    }
    return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
    if (namespaceAddress) {
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {
        const adapter = this.getAdapter(networkNamespace);
        await adapter?.switchNetwork({ caipNetwork, provider, providerType });
      } else {
        this.setCaipNetwork(caipNetwork);
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          this.syncWalletConnectAccount();
        } else {
          const address = this.getAddressByChainNamespace(networkNamespace);
          if (address) {
            this.syncAccount({
              address,
              chainId: caipNetwork.id,
              chainNamespace: networkNamespace
            });
          }
        }
      }
    } else {
      this.setCaipNetwork(caipNetwork);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      const blueprint = blueprints?.find((b3) => b3.namespace === namespace);
      if (blueprint) {
        blueprint.construct({
          namespace,
          projectId: this.options?.projectId,
          networks: this.getCaipNetworks()
        });
        adapters[namespace] = blueprint;
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.getCaipNetworks()
        });
      }
      return adapters;
    }, {});
  }
  async initChainAdapter(namespace) {
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    await this.chainAdapters?.[namespace].syncConnectors(this.options, this);
    await this.createUniversalProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter?.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address, chainId }) => {
      const caipNetwork = this.getCaipNetworks().find((n2) => n2.id === chainId || n2.caipNetworkId === chainId);
      const isSameNamespace = ChainController.state.activeChain === chainNamespace;
      const accountAddress = ChainController.getAccountProp("address", chainNamespace);
      if (caipNetwork) {
        const account = isSameNamespace && address ? address : accountAddress;
        if (account) {
          this.syncAccount({ address: account, chainId: caipNetwork.id, chainNamespace });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", this.disconnect.bind(this, chainNamespace));
    adapter.on("connections", (connections) => {
      this.setConnections(connections, chainNamespace);
    });
    adapter.on("pendingTransactions", () => {
      const address = AccountController.state.address;
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address || !activeCaipNetwork?.id) {
        return;
      }
      this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
    });
    adapter.on("accountChanged", ({ address, chainId }) => {
      const isActiveChain = ChainController.state.activeChain === chainNamespace;
      if (isActiveChain && chainId) {
        this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (isActiveChain && ChainController.state.activeCaipNetwork?.id) {
        this.syncAccount({
          address,
          chainId: ChainController.state.activeCaipNetwork?.id,
          chainNamespace
        });
      } else {
        this.syncAccountInfo(address, chainId, chainNamespace);
      }
      this.syncAllAccounts(chainNamespace);
    });
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    await this.getUniversalProvider();
    if (this.universalProvider) {
      this.chainAdapters?.[chainNamespace]?.setUniversalProvider?.(this.universalProvider);
    }
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  async syncNamespaceConnection(namespace) {
    try {
      if (namespace === ConstantsUtil.CHAIN.EVM && CoreHelperUtil.isSafeApp()) {
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.SAFE, namespace);
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case ConstantsUtil.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err) {
      console.warn("AppKit couldn't sync existing connection", err);
      this.setStatus("disconnected", namespace);
    }
  }
  async syncAdapterConnection(namespace) {
    const adapter = this.getAdapter(namespace);
    const connectorId = ConnectorController.getConnectorId(namespace);
    const caipNetwork = this.getCaipNetwork(namespace);
    const connectors = ConnectorController.getConnectors(namespace);
    const connector = connectors.find((c2) => c2.id === connectorId);
    try {
      if (!adapter || !connector) {
        throw new Error(`Adapter or connector not found for namespace ${namespace}`);
      }
      if (!caipNetwork?.id) {
        throw new Error("CaipNetwork not found");
      }
      const connection = await adapter?.syncConnection({
        namespace,
        id: connector.id,
        chainId: caipNetwork.id,
        rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0]
      });
      if (connection) {
        const accounts = await adapter?.getAccounts({
          namespace,
          id: connector.id
        });
        if (accounts && accounts.accounts.length > 0) {
          this.setAllAccounts(accounts.accounts, namespace);
        } else {
          this.setAllAccounts([CoreHelperUtil.createAccount(namespace, connection.address, "eoa")], namespace);
        }
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e) {
      this.setStatus("disconnected", namespace);
    }
  }
  async syncWalletConnectAccount() {
    const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
      const adapter = this.getAdapter(chainNamespace);
      const namespaceAccounts = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts || [];
      const activeChainId = ChainController.state.activeCaipNetwork?.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === activeChainId?.toString();
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter?.namespace !== ConstantsUtil.CHAIN.EVM) {
          const provider = adapter?.getWalletConnectProvider({
            caipNetworks: this.getCaipNetworks(),
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
        StorageUtil.addConnectedNamespace(chainNamespace);
        this.syncWalletConnectAccounts(chainNamespace);
        await this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else {
        this.setStatus("disconnected", chainNamespace);
      }
      this.syncConnectedWalletInfo(chainNamespace);
      await ChainController.setApprovedCaipNetworksData(chainNamespace);
    });
    await Promise.all(syncTasks);
  }
  syncWalletConnectAccounts(chainNamespace) {
    const addresses = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts?.map((account) => {
      const { address } = ParseUtil.parseCaipAddress(account);
      return address;
    }).filter((address, index, self) => self.indexOf(address) === index);
    if (addresses) {
      this.setAllAccounts(addresses.map((address) => CoreHelperUtil.createAccount(chainNamespace, address, chainNamespace === "bip122" ? "payment" : "eoa")), chainNamespace);
    }
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type);
    ProviderUtil.setProvider(chainNamespace, provider);
    ConnectorController.setConnectorId(id, chainNamespace);
  }
  async syncAllAccounts(namespace) {
    const connectorId = ConnectorController.getConnectorId(namespace);
    if (!connectorId) {
      return;
    }
    const adapter = this.getAdapter(namespace);
    const accounts = await adapter?.getAccounts({ namespace, id: connectorId });
    if (accounts && accounts.accounts.length > 0) {
      this.setAllAccounts(accounts.accounts, namespace);
    }
  }
  async syncAccount(params) {
    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
    const { address, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      let caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainId === chainIdToUse.toString());
        const fallBackCaipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainNamespace === chainNamespace);
        caipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n2 && n2.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if (network?.chainNamespace === ChainController.state.activeChain) {
        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      } else if (!isActiveNamespace) {
        if (networkOfChain) {
          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      if (!HelpersUtil.isLowerCaseMatch(address, AccountController.state.address)) {
        this.syncAccountInfo(address, network?.id, chainNamespace);
      }
      if (isActiveNamespace) {
        await this.syncBalance({ address, chainId: network?.id, chainNamespace });
      } else {
        await this.syncBalance({ address, chainId: networkOfChain?.id, chainNamespace });
      }
    }
  }
  async syncAccountInfo(address, chainId, chainNamespace) {
    const caipAddress = this.getCaipAddress(chainNamespace);
    const newChainId = chainId || caipAddress?.split(":")[1];
    if (!newChainId) {
      return;
    }
    const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
    this.setCaipAddress(newCaipAddress, chainNamespace);
    await this.syncIdentity({
      address,
      chainId: newChainId,
      chainNamespace
    });
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    const connectorId = ConnectorController.getConnectorId(chainNamespace);
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connector = this.getConnectors().find((c2) => c2.id === connectorId);
        if (connector) {
          const { info, name, imageUrl } = connector;
          const icon = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name, icon, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider?.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: provider.session.peer.metadata.icons?.[0]
        }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c2) => c2.id === ConstantsUtil.CONNECTOR_ID.COINBASE);
        this.setConnectedWalletInfo({ name: "Coinbase Wallet", icon: this.getConnectorImage(connector) }, chainNamespace);
      }
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(), params.chainNamespace).find((n2) => n2.id.toString() === params.chainId?.toString());
    if (!caipNetwork || !params.chainId) {
      return;
    }
    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(address, chainId, namespace) {
    const adapter = this.getAdapter(namespace);
    const caipNetwork = ChainController.getCaipNetworkByNamespace(namespace, chainId);
    if (adapter) {
      const balance = await adapter.getBalance({
        address,
        chainId,
        caipNetwork,
        tokens: this.options.tokens
      });
      this.setBalance(balance.balance, balance.symbol, namespace);
      return balance;
    }
    return void 0;
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    const logger = LoggerUtil.createLogger((error, ...args) => {
      if (error) {
        this.handleAlertError(error);
      }
      console.error(...args);
    });
    const universalProviderOptions = {
      projectId: this.options?.projectId,
      metadata: {
        name: this.options?.metadata ? this.options?.metadata.name : "",
        description: this.options?.metadata ? this.options?.metadata.description : "",
        url: this.options?.metadata ? this.options?.metadata.url : "",
        icons: this.options?.metadata ? this.options?.metadata.icons : [""]
      },
      logger
    };
    OptionsController.setManualWCControl(Boolean(this.options?.manualWCControl));
    this.universalProvider = this.options.universalProvider ?? await B.init(universalProviderOptions);
    this.listenWalletConnect();
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.universalProvider.on("display_uri", (uri) => {
        ConnectionController.setUri(uri);
      });
      this.universalProvider.on("connect", ConnectionController.finalizeWcConnection);
      this.universalProvider.on("disconnect", () => {
        this.chainNamespaces.forEach((namespace) => {
          this.resetAccount(namespace);
        });
        ConnectionController.resetWcConnection();
      });
      this.universalProvider.on("chainChanged", (chainId) => {
        const caipNetwork = this.getCaipNetworks().find((c2) => c2.id == chainId);
        const currentCaipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          this.setUnsupportedNetwork(chainId);
          return;
        }
        if (currentCaipNetwork?.id !== caipNetwork?.id) {
          this.setCaipNetwork(caipNetwork);
        }
      });
      this.universalProvider.on("session_event", (callbackData) => {
        if (WcHelpersUtil.isSessionEventData(callbackData)) {
          const { name, data } = callbackData.params.event;
          if (name === "accountsChanged" && Array.isArray(data) && CoreHelperUtil.isCaipAddress(data[0])) {
            this.syncAccount(ParseUtil.parseCaipAddress(data[0]));
          }
        }
      });
    }
  }
  createUniversalProvider() {
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && this.options?.projectId) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (err) {
        EventsController.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: err instanceof Error ? err.message : "Unknown",
            uncaught: false
          }
        });
        console.error("AppKit:getUniversalProvider - Cannot create provider", err);
      }
    }
    return this.universalProvider;
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(error) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  getAdapter(namespace) {
    if (!namespace) {
      return void 0;
    }
    return this.chainAdapters?.[namespace];
  }
  createAdapter(blueprint) {
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: this.options?.projectId,
      networks: this.getCaipNetworks()
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if (options?.uri) {
      ConnectionController.setUri(options.uri);
    }
    if (options?.arguments) {
      switch (options?.view) {
        case "Swap":
          return ModalController.open({ ...options, data: { swap: options.arguments } });
        default:
      }
    }
    return ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading, namespace) {
    ModalController.setLoading(loading, namespace);
  }
  async disconnect(chainNamespace) {
    await ConnectionController.disconnect(chainNamespace);
  }
  getSIWX() {
    return OptionsController.state.siwx;
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    return ChainController.state.activeCaipNetwork?.id;
  }
  async switchNetwork(appKitNetwork) {
    const network = this.getCaipNetworks().find((n2) => n2.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ProviderUtil.getProviderId(ChainController.state.activeChain);
  }
  subscribeProviders(callback) {
    return ProviderUtil.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getWalletInfo() {
    return AccountController.state.connectedWalletInfo;
  }
  getAccount(namespace) {
    const authConnector = ConnectorController.getAuthConnector(namespace);
    const accountState = ChainController.getAccountData(namespace);
    const activeChain = ChainController.state.activeChain;
    const activeConnectorId = StorageUtil.getConnectedConnectorId(namespace || activeChain);
    if (!accountState) {
      return void 0;
    }
    return {
      allAccounts: accountState.allAccounts,
      caipAddress: accountState.caipAddress,
      address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),
      isConnected: Boolean(accountState.caipAddress),
      status: accountState.status,
      embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
        user: accountState.user ? {
          ...accountState.user,
          /*
           * Getting the username from the chain controller works well for social logins,
           * but Farcaster uses a different connection flow and doesn't emit the username via events.
           * Since the username is stored in local storage before the chain controller updates,
           * it's safe to use the local storage value here.
           */
          username: StorageUtil.getConnectedSocialUsername()
        } : void 0,
        authProvider: accountState.socialProvider || "email",
        accountType: accountState.preferredAccountTypes?.[namespace || activeChain],
        isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
      } : void 0
    };
  }
  subscribeAccount(callback, namespace) {
    const updateVal = () => {
      const account = this.getAccount(namespace);
      if (!account) {
        return;
      }
      callback(account);
    };
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork?.id,
        caipNetworkId: activeCaipNetwork?.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback) {
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(status) {
    RouterController.popTransactionStack(status);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateRemoteFeatures(newRemoteFeatures) {
    OptionsController.setRemoteFeatures(newRemoteFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  getConnectMethodsOrder() {
    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    if (!this.getCaipNetworks().find((n2) => n2.id === extendedNetwork.id)) {
      ChainController.addNetwork(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = this.getCaipNetworks().find((n2) => n2.id === networkId);
    if (!networkToRemove) {
      return;
    }
    ChainController.removeNetwork(namespace, networkId);
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Overrides --------------------------------------------------------------
  async open(options) {
    const isConnected = ConnectorController.isConnected();
    if (!isConnected) {
      await super.open(options);
    }
  }
  async close() {
    await super.close();
    if (this.options.manualWCControl) {
      ConnectionController.finalizeWcConnection();
    }
  }
  async syncIdentity(_request) {
    return Promise.resolve();
  }
  async syncBalance(_params) {
    return Promise.resolve();
  }
  async injectModalUi() {
    if (!isInitialized && CoreHelperUtil.isClient()) {
      await import("./basic-L7XX7DUF.js");
      await import("./w3m-modal-KB55TREA.js");
      const isElementCreated = document.querySelector("w3m-modal");
      if (!isElementCreated) {
        const modal = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
      }
      isInitialized = true;
    }
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.7.8";

// node_modules/@walletconnect/ethereum-provider/node_modules/@reown/appkit/dist/esm/exports/core.js
function createAppKit(options) {
  return new AppKit({
    ...options,
    basic: true,
    sdkVersion: `html-core-${PACKAGE_VERSION}`
  });
}
export {
  AppKit,
  createAppKit
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=core-5WIRKTRI.js.map
